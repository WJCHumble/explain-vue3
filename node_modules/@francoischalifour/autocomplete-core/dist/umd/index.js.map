{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/getCompletion.ts","../../src/createStore.ts","../../src/getDefaultProps.ts","../../src/onInput.ts","../../src/getPropGetters.ts","../../src/onKeyDown.ts","../../src/stateReducer.ts","../../src/createAutocomplete.ts","../../src/getAutocompleteSetters.ts"],"sourcesContent":["import {\n  AutocompleteOptions,\n  AutocompleteSource,\n  AutocompleteState,\n  AutocompleteSuggestion,\n  GetSources,\n  PublicAutocompleteOptions,\n  PublicAutocompleteSource,\n} from './types';\n\nexport const noop = () => {};\n\nlet autocompleteId = 0;\n\nexport function generateAutocompleteId() {\n  return `autocomplete-${autocompleteId++}`;\n}\n\nexport function getItemsCount(state: AutocompleteState<any>) {\n  if (state.suggestions.length === 0) {\n    return 0;\n  }\n\n  return state.suggestions.reduce<number>(\n    (sum, suggestion) => sum + suggestion.items.length,\n    0\n  );\n}\n\nexport function isSpecialClick(event: MouseEvent): boolean {\n  const isMiddleClick = event.button === 1;\n\n  return (\n    isMiddleClick ||\n    event.altKey ||\n    event.ctrlKey ||\n    event.metaKey ||\n    event.shiftKey\n  );\n}\n\nfunction normalizeSource<TItem>(\n  source: PublicAutocompleteSource<TItem>\n): AutocompleteSource<TItem> {\n  return {\n    getInputValue({ state }) {\n      return state.query;\n    },\n    getSuggestionUrl() {\n      return undefined;\n    },\n    onSelect({ setIsOpen }) {\n      setIsOpen(false);\n    },\n    onHighlight: noop,\n    ...source,\n  };\n}\n\nexport function normalizeGetSources<TItem>(\n  getSources: PublicAutocompleteOptions<TItem>['getSources']\n): GetSources<TItem> {\n  return (options) => {\n    return Promise.resolve(getSources(options)).then((sources) =>\n      Promise.all(\n        sources.filter(Boolean).map((source) => {\n          return Promise.resolve(normalizeSource<TItem>(source));\n        })\n      )\n    );\n  };\n}\n\nexport function getNextHighlightedIndex<TItem>(\n  moveAmount: number,\n  baseIndex: number | null,\n  itemCount: number,\n  defaultHighlightedIndex: AutocompleteOptions<TItem>['defaultHighlightedIndex']\n): number | null {\n  // We allow circular keyboard navigation from the base index.\n  // The base index can either be `null` (nothing is highlighted) or `0`\n  // (the first item is highlighted).\n  // The base index is allowed to get assigned `null` only if\n  // `props.defaultHighlightedIndex` is `null`. This pattern allows to \"stop\"\n  // by the actual query before navigating to other suggestions as seen on\n  // Google or Amazon.\n  if (baseIndex === null && moveAmount < 0) {\n    return itemCount - 1;\n  }\n\n  if (defaultHighlightedIndex !== null && baseIndex === 0 && moveAmount < 0) {\n    return itemCount - 1;\n  }\n\n  const numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;\n\n  if (numericIndex <= -1 || numericIndex >= itemCount) {\n    return defaultHighlightedIndex === null ? null : 0;\n  }\n\n  return numericIndex;\n}\n\n// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getSuggestionFromHighlightedIndex<TItem>({\n  state,\n}: {\n  state: AutocompleteState<TItem>;\n}): AutocompleteSuggestion<TItem> | undefined {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  const accumulatedSuggestionsCount = state.suggestions\n    .map((suggestion) => suggestion.items.length)\n    .reduce<number[]>((acc, suggestionCount, index) => {\n      const previousValue = acc[index - 1] || 0;\n      const nextValue = previousValue + suggestionCount;\n\n      acc.push(nextValue);\n\n      return acc;\n    }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  const suggestionIndex = accumulatedSuggestionsCount.reduce((acc, current) => {\n    if (current <= state.highlightedIndex!) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n\n  return state.suggestions[suggestionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      â†‘\n *         (absolute: 3, relative: 1)\n * @param param0\n */\nfunction getRelativeHighlightedIndex<TItem>({\n  state,\n  suggestion,\n}: {\n  state: AutocompleteState<TItem>;\n  suggestion: AutocompleteSuggestion<TItem>;\n}): number {\n  let isOffsetFound = false;\n  let counter = 0;\n  let previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    const currentSuggestion = state.suggestions[counter];\n\n    if (currentSuggestion === suggestion) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentSuggestion.items.length;\n\n    counter++;\n  }\n\n  return state.highlightedIndex! - previousItemsOffset;\n}\n\nexport function getHighlightedItem<TItem>({\n  state,\n}: {\n  state: AutocompleteState<TItem>;\n}) {\n  const suggestion = getSuggestionFromHighlightedIndex({ state });\n\n  if (!suggestion) {\n    return null;\n  }\n\n  const item =\n    suggestion.items[getRelativeHighlightedIndex({ state, suggestion })];\n  const source = suggestion.source;\n  const itemValue = source.getInputValue({ suggestion: item, state });\n  const itemUrl = source.getSuggestionUrl({ suggestion: item, state });\n\n  return {\n    item,\n    itemValue,\n    itemUrl,\n    source,\n  };\n}\n\nexport function isOrContainsNode(parent: Node, child: Node) {\n  return parent === child || (parent.contains && parent.contains(child));\n}\n","import { AutocompleteOptions, AutocompleteState } from './types';\nimport { getHighlightedItem } from './utils';\n\ninterface GetCompletionProps<TItem> {\n  state: AutocompleteState<TItem>;\n  props: AutocompleteOptions<TItem>;\n}\n\nexport function getCompletion<TItem>({\n  state,\n  props,\n}: GetCompletionProps<TItem>): string | null {\n  if (\n    props.enableCompletion === false ||\n    state.isOpen === false ||\n    state.highlightedIndex === null ||\n    state.status === 'stalled'\n  ) {\n    return null;\n  }\n\n  const { itemValue } = getHighlightedItem({ state })!;\n\n  // The completion should appear only if the _first_ characters of the query\n  // match with the suggestion.\n  if (\n    state.query.length > 0 &&\n    itemValue.toLocaleLowerCase().indexOf(state.query.toLocaleLowerCase()) === 0\n  ) {\n    // If the query typed has a different case than the suggestion, we want\n    // to show the completion matching the case of the query. This makes both\n    // strings overlap correctly.\n    // Example:\n    //  - query: 'Gui'\n    //  - suggestion: 'guitar'\n    //  => completion: 'Guitar'\n    const completion = state.query + itemValue.slice(state.query.length);\n\n    if (completion === state.query) {\n      return null;\n    }\n\n    return completion;\n  }\n\n  return null;\n}\n","import { getCompletion } from './getCompletion';\nimport {\n  AutocompleteOptions,\n  AutocompleteState,\n  AutocompleteStore,\n  Reducer,\n} from './types';\n\nexport function createStore<TItem>(\n  reducer: Reducer,\n  props: AutocompleteOptions<TItem>\n): AutocompleteStore<TItem> {\n  return {\n    state: props.initialState,\n    getState() {\n      return this.state;\n    },\n    send(action, payload) {\n      this.state = withCompletion(\n        reducer({ type: action, value: payload }, this.state, props),\n        props\n      );\n\n      props.onStateChange({ state: this.state });\n    },\n  };\n}\n\nfunction withCompletion<TItem>(\n  state: AutocompleteState<TItem>,\n  props: AutocompleteOptions<TItem>\n) {\n  return {\n    ...state,\n    completion: getCompletion({ state, props }),\n  };\n}\n","import { AutocompleteOptions, PublicAutocompleteOptions } from './types';\nimport {\n  generateAutocompleteId,\n  getItemsCount,\n  noop,\n  normalizeGetSources,\n} from './utils';\n\nexport function getDefaultProps<TItem>(\n  props: PublicAutocompleteOptions<TItem>\n): AutocompleteOptions<TItem> {\n  const environment: typeof window = (typeof window !== 'undefined'\n    ? window\n    : {}) as typeof window;\n\n  return {\n    openOnFocus: false,\n    placeholder: '',\n    autoFocus: false,\n    defaultHighlightedIndex: null,\n    enableCompletion: false,\n    stallThreshold: 300,\n    environment,\n    shouldDropdownShow: ({ state }) => getItemsCount(state) > 0,\n    onStateChange: noop,\n    onSubmit: noop,\n    ...props,\n    // Since `generateAutocompleteId` triggers a side effect (it increments\n    // and internal counter), we don't want to execute it if unnecessary.\n    id: props.id ?? generateAutocompleteId(),\n    // The following props need to be deeply defaulted.\n    initialState: {\n      highlightedIndex: null,\n      query: '',\n      completion: null,\n      suggestions: [],\n      isOpen: false,\n      status: 'idle',\n      statusContext: {},\n      context: {},\n      ...props.initialState,\n    },\n    getSources: normalizeGetSources(props.getSources),\n    navigator: {\n      navigate({ suggestionUrl }) {\n        environment.location.assign(suggestionUrl);\n      },\n      navigateNewTab({ suggestionUrl }) {\n        const windowReference = environment.open(\n          suggestionUrl,\n          '_blank',\n          'noopener'\n        );\n\n        if (windowReference) {\n          windowReference.focus();\n        }\n      },\n      navigateNewWindow({ suggestionUrl }) {\n        environment.open(suggestionUrl, '_blank', 'noopener');\n      },\n      ...props.navigator,\n    },\n  };\n}\n","import {\n  AutocompleteOptions,\n  AutocompleteSetters,\n  AutocompleteState,\n  AutocompleteStore,\n} from './types';\n\nlet lastStalledId: number | null = null;\n\ninterface OnInputParams<TItem> extends AutocompleteSetters<TItem> {\n  query: string;\n  store: AutocompleteStore<TItem>;\n  props: AutocompleteOptions<TItem>;\n  /**\n   * The next partial state to apply after the function is called.\n   *\n   * This is useful when we call `onInput` in a different scenario than an\n   * actual input. For example, we use `onInput` when we click on an item,\n   * but we want to close the dropdown in that case.\n   */\n  nextState?: Partial<AutocompleteState<TItem>>;\n}\n\nexport function onInput<TItem>({\n  query,\n  store,\n  props,\n  setHighlightedIndex,\n  setQuery,\n  setSuggestions,\n  setIsOpen,\n  setStatus,\n  setContext,\n  nextState = {},\n}: OnInputParams<TItem>): Promise<void> {\n  if (props.onInput) {\n    return Promise.resolve(\n      props.onInput({\n        query,\n        state: store.getState(),\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n      })\n    );\n  }\n\n  if (lastStalledId) {\n    clearTimeout(lastStalledId);\n  }\n\n  setHighlightedIndex(props.defaultHighlightedIndex);\n  setQuery(query);\n\n  if (query.length === 0 && props.openOnFocus === false) {\n    setStatus('idle');\n    setSuggestions(\n      store.getState().suggestions.map((suggestion) => ({\n        ...suggestion,\n        items: [],\n      }))\n    );\n    setIsOpen(\n      nextState.isOpen ?? props.shouldDropdownShow({ state: store.getState() })\n    );\n\n    return Promise.resolve();\n  }\n\n  setStatus('loading');\n\n  lastStalledId = props.environment.setTimeout(() => {\n    setStatus('stalled');\n  }, props.stallThreshold);\n\n  return props\n    .getSources({\n      query,\n      state: store.getState(),\n      setHighlightedIndex,\n      setQuery,\n      setSuggestions,\n      setIsOpen,\n      setStatus,\n      setContext,\n    })\n    .then((sources) => {\n      setStatus('loading');\n\n      // @TODO: convert `Promise.all` to fetching strategy.\n      return Promise.all(\n        sources.map((source) => {\n          return Promise.resolve(\n            source.getSuggestions({\n              query,\n              state: store.getState(),\n              setHighlightedIndex,\n              setQuery,\n              setSuggestions,\n              setIsOpen,\n              setStatus,\n              setContext,\n            })\n          ).then((items) => {\n            return {\n              source,\n              items,\n            };\n          });\n        })\n      )\n        .then((suggestions) => {\n          setStatus('idle');\n          setSuggestions(suggestions as any);\n          setIsOpen(\n            nextState.isOpen ??\n              ((query.length === 0 && props.openOnFocus) ||\n                props.shouldDropdownShow({ state: store.getState() }))\n          );\n        })\n        .catch((error) => {\n          setStatus('error');\n\n          throw error;\n        })\n        .finally(() => {\n          if (lastStalledId) {\n            clearTimeout(lastStalledId);\n          }\n        });\n    });\n}\n","import { onInput } from './onInput';\nimport { onKeyDown } from './onKeyDown';\nimport {\n  AutocompleteOptions,\n  AutocompleteSetters,\n  AutocompleteStore,\n  GetDropdownProps,\n  GetEnvironmentProps,\n  GetFormProps,\n  GetInputProps,\n  GetItemProps,\n  GetLabelProps,\n  GetMenuProps,\n  GetRootProps,\n} from './types';\nimport { getHighlightedItem, isOrContainsNode, isSpecialClick } from './utils';\n\ninterface GetPropGettersOptions<TItem> extends AutocompleteSetters<TItem> {\n  store: AutocompleteStore<TItem>;\n  props: AutocompleteOptions<TItem>;\n}\n\nexport function getPropGetters<TItem, TEvent, TMouseEvent, TKeyboardEvent>({\n  store,\n  props,\n  setHighlightedIndex,\n  setQuery,\n  setSuggestions,\n  setIsOpen,\n  setStatus,\n  setContext,\n}: GetPropGettersOptions<TItem>) {\n  const getEnvironmentProps: GetEnvironmentProps = (getterProps) => {\n    return {\n      // On touch devices, we do not rely on the native `blur` event of the\n      // input to close the dropdown, but rather on a custom `touchstart` event\n      // outside of the autocomplete elements.\n      // This ensures a working experience on mobile because we blur the input\n      // on touch devices when the user starts scrolling (`touchmove`).\n      onTouchStart(event) {\n        if (\n          store.getState().isOpen === false ||\n          event.target === getterProps.inputElement\n        ) {\n          return;\n        }\n\n        const isTargetWithinAutocomplete = [\n          getterProps.searchBoxElement,\n          getterProps.dropdownElement,\n        ].some((contextNode) => {\n          return (\n            contextNode &&\n            (isOrContainsNode(contextNode, event.target as Node) ||\n              isOrContainsNode(\n                contextNode,\n                props.environment.document.activeElement!\n              ))\n          );\n        });\n\n        if (isTargetWithinAutocomplete === false) {\n          store.send('blur', null);\n        }\n      },\n      // When scrolling on touch devices (mobiles, tablets, etc.), we want to\n      // mimic the native platform behavior where the input is blurred to\n      // hide the virtual keyboard. This gives more vertical space to\n      // discover all the suggestions showing up in the dropdown.\n      onTouchMove(event: TouchEvent) {\n        if (\n          store.getState().isOpen === false ||\n          getterProps.inputElement !==\n            props.environment.document.activeElement ||\n          event.target === getterProps.inputElement\n        ) {\n          return;\n        }\n\n        getterProps.inputElement.blur();\n      },\n    };\n  };\n\n  const getRootProps: GetRootProps = (rest) => {\n    return {\n      role: 'combobox',\n      'aria-expanded': store.getState().isOpen,\n      'aria-haspopup': 'listbox',\n      'aria-owns': store.getState().isOpen ? `${props.id}-menu` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getFormProps: GetFormProps<TEvent> = (providedProps) => {\n    const { inputElement, ...rest } = providedProps;\n\n    return {\n      action: '',\n      noValidate: true,\n      role: 'search',\n      onSubmit: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onSubmit({\n          state: store.getState(),\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n          event,\n        });\n\n        store.send('submit', null);\n\n        if (providedProps.inputElement) {\n          providedProps.inputElement.blur();\n        }\n      },\n      onReset: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        if (props.openOnFocus) {\n          onInput({\n            query: '',\n            store,\n            props,\n            setHighlightedIndex,\n            setQuery,\n            setSuggestions,\n            setIsOpen,\n            setStatus,\n            setContext,\n          });\n        }\n        store.send('reset', null);\n\n        if (providedProps.inputElement) {\n          providedProps.inputElement.focus();\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getInputProps: GetInputProps<TEvent, TMouseEvent, TKeyboardEvent> = (\n    providedProps\n  ) => {\n    function onFocus() {\n      // We want to trigger a query when `openOnFocus` is true\n      // because the dropdown should open with the current query.\n      if (props.openOnFocus || store.getState().query.length > 0) {\n        onInput({\n          query: store.getState().query,\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n        });\n      }\n\n      store.send('focus', null);\n    }\n\n    const isTouchDevice = 'ontouchstart' in props.environment;\n    const { inputElement, maxLength = 512, ...rest } = providedProps || {};\n\n    return {\n      'aria-autocomplete': props.enableCompletion ? 'both' : 'list',\n      'aria-activedescendant':\n        store.getState().isOpen && store.getState().highlightedIndex !== null\n          ? `${props.id}-item-${store.getState().highlightedIndex}`\n          : undefined,\n      'aria-controls': store.getState().isOpen ? `${props.id}-menu` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      value: store.getState().query,\n      id: `${props.id}-input`,\n      autoComplete: 'off',\n      autoCorrect: 'off',\n      autoCapitalize: 'off',\n      spellCheck: 'false',\n      autoFocus: props.autoFocus,\n      placeholder: props.placeholder,\n      maxLength,\n      type: 'search',\n      onChange: (event) => {\n        onInput({\n          query: (((event as unknown) as Event)\n            .currentTarget as HTMLInputElement).value.slice(0, maxLength),\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n        });\n      },\n      onKeyDown: (event) => {\n        onKeyDown({\n          event: (event as unknown) as KeyboardEvent,\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n        });\n      },\n      onFocus,\n      onBlur: () => {\n        // We do rely on the `blur` event on touch devices.\n        // See explanation in `onTouchStart`.\n        if (!isTouchDevice) {\n          store.send('blur', null);\n        }\n      },\n      onClick: () => {\n        // When the dropdown is closed and you click on the input while\n        // the input is focused, the `onFocus` event is not triggered\n        // (default browser behavior).\n        // In an autocomplete context, it makes sense to open the menu in this\n        // case.\n        // We mimic this event by catching the `onClick` event which\n        // triggers the `onFocus` for the dropdown to open.\n        if (\n          providedProps.inputElement ===\n            props.environment.document.activeElement &&\n          !store.getState().isOpen\n        ) {\n          onFocus();\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getLabelProps: GetLabelProps = (rest) => {\n    return {\n      htmlFor: `${props.id}-input`,\n      id: `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getMenuProps: GetMenuProps = (rest) => {\n    return {\n      role: 'listbox',\n      'aria-labelledby': `${props.id}-label`,\n      id: `${props.id}-menu`,\n      ...rest,\n    };\n  };\n\n  const getDropdownProps: GetDropdownProps<TMouseEvent> = (rest) => {\n    return {\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the dropdown so\n        // that the blur event is not triggered, otherwise it closes the\n        // dropdown.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onMouseLeave() {\n        store.send('mouseleave', null);\n      },\n      ...rest,\n    };\n  };\n\n  const getItemProps: GetItemProps<any, TMouseEvent> = (providedProps) => {\n    const { item, source, ...rest } = providedProps;\n\n    return {\n      id: `${props.id}-item-${item.__autocomplete_id}`,\n      role: 'option',\n      'aria-selected':\n        store.getState().highlightedIndex === item.__autocomplete_id,\n      onMouseMove(event) {\n        if (item.__autocomplete_id === store.getState().highlightedIndex) {\n          return;\n        }\n\n        store.send('mousemove', item.__autocomplete_id);\n\n        const highlightedItem = getHighlightedItem({\n          state: store.getState(),\n        });\n\n        if (store.getState().highlightedIndex !== null && highlightedItem) {\n          const { item, itemValue, itemUrl, source } = highlightedItem;\n\n          source.onHighlight({\n            suggestion: item,\n            suggestionValue: itemValue,\n            suggestionUrl: itemUrl,\n            source,\n            state: store.getState(),\n            setHighlightedIndex,\n            setQuery,\n            setSuggestions,\n            setIsOpen,\n            setStatus,\n            setContext,\n            event,\n          });\n        }\n      },\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the item so it\n        // can remain with the current `activeElement`.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onClick(event) {\n        // If `getSuggestionUrl` is provided, it means that the suggestion\n        // is a link, not plain text that aims at updating the query.\n        // We can therefore skip the state change because it will update\n        // the `highlightedIndex`, resulting in a UI flash, especially\n        // noticeable on mobile.\n        if (\n          source.getSuggestionUrl({\n            suggestion: item,\n            state: store.getState(),\n          }) !== undefined\n        ) {\n          return;\n        }\n\n        // We ignore all modified clicks to support default browsers' behavior.\n        if (isSpecialClick((event as unknown) as MouseEvent)) {\n          return;\n        }\n\n        const inputValue = source.getInputValue({\n          suggestion: item,\n          state: store.getState(),\n        });\n\n        onInput({\n          query: inputValue,\n          store,\n          props,\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n          nextState: {\n            isOpen: false,\n          },\n        }).then(() => {\n          source.onSelect({\n            suggestion: item,\n            suggestionValue: inputValue,\n            suggestionUrl: source.getSuggestionUrl({\n              suggestion: item,\n              state: store.getState(),\n            }),\n            source,\n            state: store.getState(),\n            setHighlightedIndex,\n            setQuery,\n            setSuggestions,\n            setIsOpen,\n            setStatus,\n            setContext,\n            event,\n          });\n        });\n      },\n      ...rest,\n    };\n  };\n\n  return {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getDropdownProps,\n    getMenuProps,\n    getItemProps,\n  };\n}\n","import { getCompletion } from './getCompletion';\nimport { onInput } from './onInput';\nimport {\n  AutocompleteOptions,\n  AutocompleteSetters,\n  AutocompleteStore,\n} from './types';\nimport { getHighlightedItem } from './utils';\n\ninterface OnKeyDownOptions<TItem> extends AutocompleteSetters<TItem> {\n  event: KeyboardEvent;\n  store: AutocompleteStore<TItem>;\n  props: AutocompleteOptions<TItem>;\n}\n\nexport function onKeyDown<TItem>({\n  event,\n  store,\n  props,\n  setHighlightedIndex,\n  setQuery,\n  setSuggestions,\n  setIsOpen,\n  setStatus,\n  setContext,\n}: OnKeyDownOptions<TItem>): void {\n  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n    // Default browser behavior changes the caret placement on ArrowUp and\n    // Arrow down.\n    event.preventDefault();\n\n    store.send(event.key, { shiftKey: event.shiftKey });\n\n    const nodeItem = props.environment.document.getElementById(\n      `${props.id}-item-${store.getState().highlightedIndex}`\n    );\n    nodeItem?.scrollIntoView(false);\n\n    const highlightedItem = getHighlightedItem({\n      state: store.getState(),\n    });\n\n    if (store.getState().highlightedIndex !== null && highlightedItem) {\n      const { item, itemValue, itemUrl, source } = highlightedItem;\n\n      source.onHighlight({\n        suggestion: item,\n        suggestionValue: itemValue,\n        suggestionUrl: itemUrl,\n        source,\n        state: store.getState(),\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n        event,\n      });\n    }\n  } else if (\n    (event.key === 'Tab' ||\n      // When the user hits the right arrow and is at the end of the input\n      // query, we validate the completion.\n      (event.key === 'ArrowRight' &&\n        (event.target as HTMLInputElement).selectionStart ===\n          store.getState().query.length)) &&\n    props.enableCompletion &&\n    store.getState().highlightedIndex !== null\n  ) {\n    event.preventDefault();\n\n    const query = getCompletion({ state: store.getState(), props });\n\n    if (query) {\n      onInput({\n        query,\n        store,\n        props,\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n      });\n    }\n  } else if (event.key === 'Escape') {\n    // This prevents the default browser behavior on `input[type=\"search\"]`\n    // to remove the query right away because we first want to close the\n    // dropdown.\n    event.preventDefault();\n\n    store.send(event.key, null);\n  } else if (event.key === 'Enter') {\n    // No item is selected, so we let the browser handle the native `onSubmit`\n    // form event.\n    if (\n      store.getState().highlightedIndex === null ||\n      store\n        .getState()\n        .suggestions.every((suggestion) => suggestion.items.length === 0)\n    ) {\n      return;\n    }\n\n    // This prevents the `onSubmit` event to be sent because an item is\n    // highlighted.\n    event.preventDefault();\n\n    const { item, itemValue, itemUrl, source } = getHighlightedItem({\n      state: store.getState(),\n    })!;\n\n    if (event.metaKey || event.ctrlKey) {\n      if (itemUrl !== undefined) {\n        props.navigator.navigateNewTab({\n          suggestionUrl: itemUrl,\n          suggestion: item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.shiftKey) {\n      if (itemUrl !== undefined) {\n        props.navigator.navigateNewWindow({\n          suggestionUrl: itemUrl,\n          suggestion: item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.altKey) {\n      // Keep native browser behavior\n    } else {\n      onInput({\n        query: itemValue,\n        store,\n        props,\n        setHighlightedIndex,\n        setQuery,\n        setSuggestions,\n        setIsOpen,\n        setStatus,\n        setContext,\n        nextState: {\n          isOpen: false,\n        },\n      }).then(() => {\n        source.onSelect({\n          suggestion: item,\n          suggestionValue: itemValue,\n          suggestionUrl: itemUrl,\n          source,\n          state: store.getState(),\n          setHighlightedIndex,\n          setQuery,\n          setSuggestions,\n          setIsOpen,\n          setStatus,\n          setContext,\n          event,\n        });\n      });\n\n      if (itemUrl !== undefined) {\n        props.navigator.navigate({\n          suggestionUrl: itemUrl,\n          suggestion: item,\n          state: store.getState(),\n        });\n      }\n    }\n  }\n}\n","import { Reducer } from './types';\nimport { getItemsCount, getNextHighlightedIndex } from './utils';\n\nexport const stateReducer: Reducer = (action, state, props) => {\n  switch (action.type) {\n    case 'setHighlightedIndex': {\n      return {\n        ...state,\n        highlightedIndex: action.value,\n      };\n    }\n\n    case 'setQuery': {\n      return {\n        ...state,\n        query: action.value,\n      };\n    }\n\n    case 'setSuggestions': {\n      return {\n        ...state,\n        suggestions: action.value,\n      };\n    }\n\n    case 'setIsOpen': {\n      return {\n        ...state,\n        isOpen: action.value,\n      };\n    }\n\n    case 'setStatus': {\n      return {\n        ...state,\n        status: action.value,\n      };\n    }\n\n    case 'setContext': {\n      return {\n        ...state,\n        context: {\n          ...state.context,\n          ...action.value,\n        },\n      };\n    }\n\n    case 'ArrowDown': {\n      return {\n        ...state,\n        highlightedIndex: getNextHighlightedIndex(\n          1,\n          state.highlightedIndex,\n          getItemsCount(state),\n          props.defaultHighlightedIndex\n        ),\n      };\n    }\n\n    case 'ArrowUp': {\n      return {\n        ...state,\n        highlightedIndex: getNextHighlightedIndex(\n          -1,\n          state.highlightedIndex,\n          getItemsCount(state),\n          props.defaultHighlightedIndex\n        ),\n      };\n    }\n\n    case 'Escape': {\n      if (state.isOpen) {\n        return {\n          ...state,\n          isOpen: false,\n        };\n      }\n\n      return {\n        ...state,\n        query: '',\n        status: 'idle',\n        statusContext: {},\n        suggestions: [],\n      };\n    }\n\n    case 'submit': {\n      return {\n        ...state,\n        highlightedIndex: null,\n        isOpen: false,\n        status: 'idle',\n        statusContext: {},\n      };\n    }\n\n    case 'reset': {\n      return {\n        ...state,\n        highlightedIndex:\n          // Since we open the menu on reset when openOnFocus=true\n          // we need to restore the highlighted index to the defaultHighlightedIndex. (DocSearch use-case)\n\n          // Since we close the menu when openOnFocus=false\n          // we lose track of the highlighted index. (Query-suggestions use-case)\n          props.openOnFocus === true ? props.defaultHighlightedIndex : null,\n        isOpen: props.openOnFocus, // @TODO: Check with UX team if we want to close the menu on reset.\n        status: 'idle',\n        statusContext: {},\n        query: '',\n      };\n    }\n\n    case 'focus': {\n      return {\n        ...state,\n        highlightedIndex: props.defaultHighlightedIndex,\n        isOpen: props.openOnFocus || state.query.length > 0,\n      };\n    }\n\n    case 'blur': {\n      return {\n        ...state,\n        isOpen: false,\n        highlightedIndex: null,\n      };\n    }\n\n    case 'mousemove': {\n      return {\n        ...state,\n        highlightedIndex: action.value,\n      };\n    }\n\n    case 'mouseleave': {\n      return {\n        ...state,\n        highlightedIndex: props.defaultHighlightedIndex,\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n","import { createStore } from './createStore';\nimport { getAutocompleteSetters } from './getAutocompleteSetters';\nimport { getDefaultProps } from './getDefaultProps';\nimport { getPropGetters } from './getPropGetters';\nimport { onInput } from './onInput';\nimport { stateReducer } from './stateReducer';\nimport { AutocompleteApi, PublicAutocompleteOptions } from './types';\n\nexport function createAutocomplete<\n  TItem extends {},\n  TEvent = Event,\n  TMouseEvent = MouseEvent,\n  TKeyboardEvent = KeyboardEvent\n>(\n  options: PublicAutocompleteOptions<TItem>\n): AutocompleteApi<TItem, TEvent, TMouseEvent, TKeyboardEvent> {\n  const props = getDefaultProps(options);\n  const store = createStore(stateReducer, props);\n\n  const {\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n  } = getAutocompleteSetters({ store });\n  const {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getDropdownProps,\n    getMenuProps,\n    getItemProps,\n  } = getPropGetters<TItem, TEvent, TMouseEvent, TKeyboardEvent>({\n    store,\n    props,\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n  });\n\n  function refresh() {\n    return onInput({\n      query: store.getState().query,\n      store,\n      props,\n      setHighlightedIndex,\n      setQuery,\n      setSuggestions,\n      setIsOpen,\n      setStatus,\n      setContext,\n    });\n  }\n\n  return {\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getInputProps,\n    getLabelProps,\n    getDropdownProps,\n    getMenuProps,\n    getItemProps,\n    refresh,\n  };\n}\n","import { AutocompleteApi, AutocompleteStore } from './types';\n\ninterface GetAutocompleteSettersOptions<TItem> {\n  store: AutocompleteStore<TItem>;\n}\n\nexport function getAutocompleteSetters<TItem>({\n  store,\n}: GetAutocompleteSettersOptions<TItem>) {\n  const setHighlightedIndex: AutocompleteApi<TItem>['setHighlightedIndex'] = (\n    value\n  ) => {\n    store.send('setHighlightedIndex', value);\n  };\n\n  const setQuery: AutocompleteApi<TItem>['setQuery'] = (value) => {\n    store.send('setQuery', value);\n  };\n\n  const setSuggestions: AutocompleteApi<TItem>['setSuggestions'] = (\n    rawValue\n  ) => {\n    let baseItemId = 0;\n    const value = rawValue.map((suggestion) => ({\n      ...suggestion,\n      items: suggestion.items.map((item) => ({\n        ...item,\n        __autocomplete_id: baseItemId++,\n      })),\n    }));\n\n    store.send('setSuggestions', value);\n  };\n\n  const setIsOpen: AutocompleteApi<TItem>['setIsOpen'] = (value) => {\n    store.send('setIsOpen', value);\n  };\n\n  const setStatus: AutocompleteApi<TItem>['setStatus'] = (value) => {\n    store.send('setStatus', value);\n  };\n\n  const setContext: AutocompleteApi<TItem>['setContext'] = (value) => {\n    store.send('setContext', value);\n  };\n\n  return {\n    setHighlightedIndex,\n    setQuery,\n    setSuggestions,\n    setIsOpen,\n    setStatus,\n    setContext,\n  };\n}\n"],"names":["noop","autocompleteId","getItemsCount","state","suggestions","length","reduce","sum","suggestion","items","normalizeGetSources","getSources","options","Promise","resolve","then","sources","all","filter","Boolean","map","source","getInputValue","query","getSuggestionUrl","onSelect","setIsOpen","onHighlight","normalizeSource","getNextHighlightedIndex","moveAmount","baseIndex","itemCount","defaultHighlightedIndex","numericIndex","getHighlightedItem","suggestionIndex","acc","suggestionCount","index","nextValue","push","current","highlightedIndex","getSuggestionFromHighlightedIndex","item","isOffsetFound","counter","previousItemsOffset","currentSuggestion","getRelativeHighlightedIndex","itemValue","itemUrl","isOrContainsNode","parent","child","contains","getCompletion","props","enableCompletion","isOpen","status","toLocaleLowerCase","indexOf","completion","slice","createStore","reducer","initialState","getState","this","send","action","payload","withCompletion","type","value","onStateChange","getDefaultProps","environment","window","openOnFocus","placeholder","autoFocus","stallThreshold","shouldDropdownShow","onSubmit","id","statusContext","context","navigator","navigate","suggestionUrl","location","assign","navigateNewTab","windowReference","open","focus","navigateNewWindow","lastStalledId","onInput","store","setHighlightedIndex","setQuery","setSuggestions","setStatus","setContext","nextState","clearTimeout","setTimeout","getSuggestions","catch","error","finally","getPropGetters","getEnvironmentProps","getterProps","onTouchStart","event","target","inputElement","searchBoxElement","dropdownElement","some","contextNode","document","activeElement","onTouchMove","blur","getRootProps","rest","role","undefined","getFormProps","providedProps","noValidate","preventDefault","onReset","getLabelProps","htmlFor","getInputProps","onFocus","isTouchDevice","maxLength","autoComplete","autoCorrect","autoCapitalize","spellCheck","onChange","currentTarget","onKeyDown","key","shiftKey","nodeItem","getElementById","scrollIntoView","highlightedItem","suggestionValue","selectionStart","every","metaKey","ctrlKey","altKey","onBlur","onClick","getDropdownProps","onMouseDown","onMouseLeave","getMenuProps","getItemProps","__autocomplete_id","onMouseMove","button","isSpecialClick","inputValue","stateReducer","rawValue","baseItemId","getAutocompleteSetters","refresh"],"mappings":"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"}