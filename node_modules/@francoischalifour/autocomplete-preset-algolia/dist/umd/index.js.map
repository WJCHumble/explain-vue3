{"version":3,"file":"index.js","sources":["../../src/results.ts","../../src/formatting.ts","../../src/utils.ts"],"sourcesContent":["import { flatten } from './utils';\n\ntype SearchClient = any;\nexport type Client = any;\ntype SearchResponse = any;\ntype QueryParameters = any;\n\ninterface SearchParameters {\n  indexName: string;\n  query: string;\n  params?: QueryParameters;\n}\n\ninterface GetAlgoliaSourceParams {\n  searchClient: SearchClient;\n  queries: SearchParameters[];\n}\n\nfunction getAlgoliaSource({ searchClient, queries }: GetAlgoliaSourceParams) {\n  if (typeof (searchClient as Client).addAlgoliaAgent === 'function') {\n    (searchClient as Client).addAlgoliaAgent('autocomplete-core', __VERSION__);\n  }\n\n  return searchClient.search(\n    queries.map((searchParameters) => {\n      const { indexName, query, params } = searchParameters;\n\n      return {\n        indexName,\n        query,\n        params: {\n          hitsPerPage: 5,\n          highlightPreTag: '<mark>',\n          highlightPostTag: '</mark>',\n          ...params,\n        },\n      };\n    })\n  );\n}\n\nexport function getAlgoliaResults({\n  searchClient,\n  queries,\n}: GetAlgoliaSourceParams): Promise<SearchResponse['results']> {\n  return getAlgoliaSource({ searchClient, queries }).then((response) => {\n    return response.results;\n  });\n}\n\nexport function getAlgoliaHits({\n  searchClient,\n  queries,\n}: GetAlgoliaSourceParams): Promise<SearchResponse['hits']> {\n  return getAlgoliaSource({ searchClient, queries }).then((response) => {\n    const results = response.results;\n\n    // @TODO: should `getAlgoliaHits` flatten the hits?\n    return flatten(results.map((result) => result.hits));\n  });\n}\n","type ParseAttributeParams = {\n  highlightPreTag?: string;\n  highlightPostTag?: string;\n  highlightedValue: string;\n};\n\ntype ParsedAttribute = { value: string; isHighlighted: boolean };\n\nexport function parseAttribute({\n  highlightPreTag = '<mark>',\n  highlightPostTag = '</mark>',\n  highlightedValue,\n}: ParseAttributeParams): ParsedAttribute[] {\n  const splitByPreTag = highlightedValue.split(highlightPreTag);\n  const firstValue = splitByPreTag.shift();\n  const elements = !firstValue\n    ? []\n    : [{ value: firstValue, isHighlighted: false }];\n\n  if (highlightPostTag === highlightPreTag) {\n    let isHighlighted = true;\n\n    splitByPreTag.forEach((split) => {\n      elements.push({ value: split, isHighlighted });\n      isHighlighted = !isHighlighted;\n    });\n  } else {\n    splitByPreTag.forEach((split) => {\n      const splitByPostTag = split.split(highlightPostTag);\n\n      elements.push({\n        value: splitByPostTag[0],\n        isHighlighted: true,\n      });\n\n      if (splitByPostTag[1] !== '') {\n        elements.push({\n          value: splitByPostTag[1],\n          isHighlighted: false,\n        });\n      }\n    });\n  }\n\n  return elements;\n}\n\nfunction getAttributeValueByPath(hit: object, path: string): string {\n  const parts = path.split('.');\n  const value = parts.reduce((current, key) => current && current[key], hit);\n\n  if (typeof value !== 'string') {\n    throw new Error(\n      `The attribute ${JSON.stringify(path)} does not exist on the hit.`\n    );\n  }\n\n  return value;\n}\n\ntype SharedParseAttributeParams = {\n  hit: any;\n  attribute: string;\n  highlightPreTag?: string;\n  highlightPostTag?: string;\n};\n\nexport function parseHighlightedAttribute({\n  hit,\n  attribute,\n  highlightPreTag,\n  highlightPostTag,\n}: SharedParseAttributeParams): ParsedAttribute[] {\n  const highlightedValue = getAttributeValueByPath(\n    hit,\n    `_highlightResult.${attribute}.value`\n  );\n\n  return parseAttribute({\n    highlightPreTag,\n    highlightPostTag,\n    highlightedValue,\n  });\n}\n\nexport function parseReverseHighlightedAttribute({\n  hit,\n  attribute,\n  highlightPreTag,\n  highlightPostTag,\n}: SharedParseAttributeParams): ParsedAttribute[] {\n  const highlightedValue = getAttributeValueByPath(\n    hit,\n    `_highlightResult.${attribute}.value`\n  );\n\n  const parts = parseAttribute({\n    highlightPreTag,\n    highlightPostTag,\n    highlightedValue,\n  });\n\n  // We don't want to highlight the whole word when no parts match.\n  if (!parts.some((part) => part.isHighlighted)) {\n    return parts.map((part) => ({ ...part, isHighlighted: false }));\n  }\n\n  return parts.map((part) => ({ ...part, isHighlighted: !part.isHighlighted }));\n}\n\nexport function parseSnippetedAttribute({\n  hit,\n  attribute,\n  highlightPreTag,\n  highlightPostTag,\n}: SharedParseAttributeParams): ParsedAttribute[] {\n  const highlightedValue = getAttributeValueByPath(\n    hit,\n    `_snippetResult.${attribute}.value`\n  );\n\n  return parseAttribute({\n    highlightPreTag,\n    highlightPostTag,\n    highlightedValue,\n  });\n}\n","export function flatten<TType = any>(values: TType[]): TType[] {\n  return values.reduce<TType[]>((a, b) => {\n    return a.concat(b);\n  }, []);\n}\n"],"names":["getAlgoliaSource","searchClient","queries","addAlgoliaAgent","undefined","search","map","searchParameters","indexName","query","params","hitsPerPage","highlightPreTag","highlightPostTag","parseAttribute","splitByPreTag","highlightedValue","split","firstValue","shift","elements","value","isHighlighted","forEach","push","splitByPostTag","getAttributeValueByPath","hit","path","reduce","current","key","Error","JSON","stringify","then","response","results","result","hits","a","b","concat","attribute","parts","some","part"],"mappings":";s6BAkBA,SAASA,SAAmBC,IAAAA,aAAcC,IAAAA,cACgB,mBAA5CD,EAAwBE,iBACjCF,EAAwBE,gBAAgB,yBAAqBC,GAGzDH,EAAaI,OAClBH,EAAQI,KAAI,SAACC,SAGJ,CACLC,UAHmCD,EAA7BC,UAINC,MAJmCF,EAAlBE,MAKjBC,UACEC,YAAa,EACbC,gBAAiB,SACjBC,iBAAkB,WAReN,EAAXG,aCjBzB,SAASI,aACdF,gBAAAA,aAAkB,eAClBC,iBAAAA,aAAmB,YAGbE,IAFNC,iBAEuCC,MAAML,GACvCM,EAAaH,EAAcI,QAC3BC,EAAYF,EAEd,CAAC,CAAEG,MAAOH,EAAYI,eAAe,IADrC,MAGAT,IAAqBD,EAAiB,KACpCU,GAAgB,EAEpBP,EAAcQ,SAAQ,SAACN,GACrBG,EAASI,KAAK,CAAEH,MAAOJ,EAAOK,cAAAA,IAC9BA,GAAiBA,UAGnBP,EAAcQ,SAAQ,SAACN,OACfQ,EAAiBR,EAAMA,MAAMJ,GAEnCO,EAASI,KAAK,CACZH,MAAOI,EAAe,GACtBH,eAAe,IAGS,KAAtBG,EAAe,IACjBL,EAASI,KAAK,CACZH,MAAOI,EAAe,GACtBH,eAAe,cAMhBF,EAGT,SAASM,EAAwBC,EAAaC,OAEtCP,EADQO,EAAKX,MAAM,KACLY,QAAO,SAACC,EAASC,UAAQD,GAAWA,EAAQC,KAAMJ,MAEjD,iBAAVN,QACH,IAAIW,8BACSC,KAAKC,UAAUN,0CAI7BP,mBDPF,mBAIErB,EAAiB,CAAEC,eAH1BA,aAGwCC,UAFxCA,UAEmDiC,MAAK,SAACC,OACjDC,EAAUD,EAASC,eAGVA,EAAQ/B,KAAI,SAACgC,UAAWA,EAAOC,QEzDlCV,QAAgB,SAACW,EAAGC,UACzBD,EAAEE,OAAOD,KACf,4BFsCE,mBAIEzC,EAAiB,CAAEC,eAH1BA,aAGwCC,UAFxCA,UAEmDiC,MAAK,SAACC,UAChDA,EAASC,wCCqBb,gBACLV,IAAAA,IACAgB,IAAAA,iBASO7B,EAAe,CACpBF,kBATFA,gBAUEC,mBATFA,iBAUEG,iBARuBU,EACvBC,6BACoBgB,mDAUjB,gBACLhB,IAAAA,IACAgB,IAAAA,UASMC,EAAQ9B,EAAe,CAC3BF,kBATFA,gBAUEC,mBATFA,iBAUEG,iBARuBU,EACvBC,6BACoBgB,sBAUjBC,EAAMC,MAAK,SAACC,UAASA,EAAKxB,iBAIxBsB,EAAMtC,KAAI,SAACwC,iBAAeA,OAAMxB,eAAgBwB,EAAKxB,mBAHnDsB,EAAMtC,KAAI,SAACwC,iBAAeA,OAAMxB,eAAe,kCAMnD,gBACLK,IAAAA,IACAgB,IAAAA,iBASO7B,EAAe,CACpBF,kBATFA,gBAUEC,mBATFA,iBAUEG,iBARuBU,EACvBC,2BACkBgB"}