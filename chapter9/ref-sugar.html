<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
      Ref 语法糖在项目中的使用 | Vue3 源码解读
    </title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/explain-vue3/assets/style.db5c977a.css">
    <link rel="modulepreload" href="/explain-vue3/assets/framework.5c8a4622.js">
    <link rel="modulepreload" href="/explain-vue3/assets/Home.791df5e7.js">
    <link rel="modulepreload" href="/explain-vue3/assets/chapter9_ref-sugar.md.43fc6c12.lean.js">
    <link rel="modulepreload" href="/explain-vue3/assets/app.d1857a09.js">
    <style>img { border-radius: 10px }h1.title { margin-left: 0.5em }</style>
    
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-6e7c0b86><div class="sidebar-button" data-v-6e7c0b86><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/explain-vue3/" aria-label="Vue3 源码解读, back to home" data-v-6e7c0b86 data-v-00c3af85><!----> Vue3 源码解读</a><div class="flex-grow" data-v-6e7c0b86></div><div class="nav" data-v-6e7c0b86><nav class="nav-links" data-v-6e7c0b86 data-v-f465d38e><!--[--><div class="item" data-v-f465d38e><div class="nav-link" data-v-f465d38e data-v-98431d6e><a class="item isExternal" href="https://github.com/WJCHumble/explain-vue3.0" target="_blank" rel="noopener noreferrer" data-v-98431d6e>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-98431d6e><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-58e261f2><nav class="nav-links nav" data-v-58e261f2 data-v-f465d38e><!--[--><div class="item" data-v-f465d38e><div class="nav-link" data-v-f465d38e data-v-98431d6e><a class="item isExternal" href="https://github.com/WJCHumble/explain-vue3.0" target="_blank" rel="noopener noreferrer" data-v-98431d6e>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-98431d6e><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-58e261f2><!--[--><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>准备工作</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter1/" data-v-58e261f2>Introduction</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>模板编译</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter2/" data-v-58e261f2>Introduction</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter2/baseParse" data-v-58e261f2>baseParse</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter2/transform" data-v-58e261f2>transform</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter2/generate" data-v-58e261f2>generate</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>组件创建过程</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter3/" data-v-58e261f2>Introduction</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter3/setupComponent" data-v-58e261f2>setupComponent</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter3/finishComponentSetup" data-v-58e261f2>finishComponentSetup</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>组件更新过程</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter4/" data-v-58e261f2>Introduction</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>基于 Proxy 的响应式原理</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter5/" data-v-58e261f2>Introduction</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter5/reactive" data-v-58e261f2>reactive</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter5/depCollection" data-v-58e261f2>依赖收集</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter5/notifyUpdate" data-v-58e261f2>派发更新</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>内置组件</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter6/" data-v-58e261f2>Introduction</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter6/teleport" data-v-58e261f2>teleport</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>常用指令</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter7/" data-v-58e261f2>Introduction</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter7/v-if" data-v-58e261f2>v-if</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter7/v-show" data-v-58e261f2>v-show</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>特性</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter8/" data-v-58e261f2>Introduction</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter8/styleCssVars" data-v-58e261f2>style css variable injection</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>语法糖</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter9/" data-v-58e261f2>Introduction</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/explain-vue3/chapter9/ref-sugar" data-v-58e261f2>ref sugar</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-b109f666><div class="container" data-v-b109f666><!--[--><!--]--><div class="content" data-v-b109f666><div data-v-b109f666><h2 id="ref-语法糖在项目中的使用"><a class="header-anchor" href="#ref-语法糖在项目中的使用" aria-hidden="true">#</a> Ref 语法糖在项目中的使用</h2><p>由于 <code>ref</code> 语法糖目前还处于实验性的（Experimental）阶段，所以在 Vue3 中不会默认支持 <code>ref</code> 语法糖。那么，这里我们以使用 Vite + Vue3 项目开发为例，看一下如何开启对 <code>ref</code> 语法糖的支持。</p><p>在使用 Vite + Vue3 项目开发时，是由 <code>@vitejs/plugin-vue</code> 插件来实现对 <code>.vue</code> 文件的代码转换（Transform）、热更新（HMR）等。所以，我们需要在 <code>vite.config.js</code> 中给 <code>@vitejs/plugin-vue</code> 插件的选项（Options）传入 <code>refTransform: true</code>：</p><div class="language-javascript"><pre><code><span class="token comment">// vite.config.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vite&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> vue <span class="token keyword">from</span> <span class="token string">&quot;@vitejs/plugin-vue&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      refTransform<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>那么，这样一来 <code>@vitejs/plugin-vue</code> 插件内部会根据传入的选项中 <code>refTransform</code> 的值判断是否需要对 <code>ref</code> 语法糖进行特定的代码转换。由于，这里我们设置的是 <code>true</code>，显然它是会对 <code>ref</code> 语法糖执行特定的代码转换。</p><p>接着，我们就可以在 <code>.vue</code> 文件中使用 <code>ref</code> 语法糖，这里我们看一个简单的例子：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{count}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>add<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>对应渲染到页面上：</p><p><img src="https://wuzhiwei.oss-cn-beijing.aliyuncs.com/Blog/vue3/%E6%88%AA%E5%B1%8F2021-09-11%20%E4%B8%8B%E5%8D%886.28.50.png" alt=""></p><p>可以看到，我们可以使用 <code>ref</code> 语法糖的方式创建响应式的变量，而不用思考使用的时候要加 <code>.value</code> 的问题。此外，<code>ref</code> 语法糖还支持其他的写法，个人比较推荐的是这里介绍的 <code>$ref</code> 的方式，有兴趣的同学可以去 RFC 上了解其他的写法。</p><p>那么，在了解完 <code>ref</code> 语法糖在项目中的使用后，我们算是解答了第一个疑问（怎么在项目中使用）。下面，我们来解答第二个疑问，它又是怎么实现的，也就是在源码中做了哪些处理？</p><h2 id="ref-语法糖的实现"><a class="header-anchor" href="#ref-语法糖的实现" aria-hidden="true">#</a> Ref 语法糖的实现</h2><p>首先，我们通过 <a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiXG48dGVtcGxhdGU+XG5cdDxkaXY+e3tjb3VudH19PC9kaXY+XG5cdDxidXR0b24gQGNsaWNrPVwiYWRkXCI+Y2xpY2sgbWU8L2J1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQgc2V0dXA+XG5sZXQgY291bnQgPSAkcmVmKDEpXG5cbmZ1bmN0aW9uIGFkZCgpIHtcblx0Y291bnQrK1xufVxuPC9zY3JpcHQ+In0=" target="_blank" rel="noopener noreferrer">Vue Playground</a> 来直观地感受一下，前面使用 <code>ref</code> 语法糖的例子中的 <code>&lt;script setup&gt;</code> 块（Block）在编译后的结果：</p><div class="language-javascript"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token keyword">as</span> _ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> __sfc__ <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">__props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">_ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token punctuation">.</span>value<span class="token operator">++</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，虽然我们在使用 <code>ref</code> 语法糖的时候不需要处理 <code>.value</code>，但是它经过编译后<strong>仍然是使用的 <code>.value</code></strong>。那么，这个过程肯定不难免要做很多<strong>编译相关</strong>的代码转换处理。因为，我们需要找到使用 <code>$ref</code> 的声明语句和变量，给前者重写为 <code>_ref</code>，给后者添加 <code>.value</code>。</p><p>而在前面，我们也提及 <code>@vitejs/plugin-vue</code> 插件会对 <code>.vue</code> 文件进行代码的转换，这个过程则是使用的 Vue3 提供的 <code>@vue/compiler-sfc</code> 包（Package），它分别提供了对 <code>&lt;script&gt;</code>、<code>&lt;template&gt;</code>、<code>&lt;style&gt;</code> 等块的编译相关的函数。</p><p>那么，显然这里我们需要关注的是 <code>&lt;script&gt;</code> 块编译相关的函数，这对应的是 <code>@vue/compiler-sfc</code> 中的 <code>compileScript()</code> 函数。</p><h3 id="compilescript-函数"><a class="header-anchor" href="#compilescript-函数" aria-hidden="true">#</a> compileScript() 函数</h3><p><code>compileScript()</code> 函数定义在 <code>vue-next</code> 的 <code>packages/compiler-sfc/src/compileScript.ts</code> 文件中，它主要负责对 <code>&lt;script&gt;</code> 或 <code>&lt;script setup&gt;</code> 块内容的编译处理，它会接收 2 个参数：</p><ul><li><code>sfc</code> 包含 <code>.vue</code> 文件的代码被解析后的内容，包含 <code>script</code>、<code>scriptSetup</code>、<code>source</code> 等属性</li><li><code>options</code> 包含一些可选和必须的属性，例如组件对应的 <code>scopeId</code> 会作为 <code>options.id</code>、前面提及的 <code>refTransform</code> 等</li></ul><p><code>compileScript()</code> 函数的定义（伪代码）：</p><div class="language-javascript"><pre><code><span class="token comment">// packages/compiler-sfc/src/compileScript.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">compileScript</span><span class="token punctuation">(</span>
  <span class="token parameter">sfc<span class="token operator">:</span> SFCDescriptor<span class="token punctuation">,</span>
  options<span class="token operator">:</span> SFCScriptCompileOptions</span>
<span class="token punctuation">)</span><span class="token operator">:</span> SFCScriptBlock <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>script<span class="token punctuation">,</span>
    content<span class="token punctuation">,</span>
    map<span class="token punctuation">,</span>
    bindings<span class="token punctuation">,</span>
    scriptAst<span class="token operator">:</span> scriptAst<span class="token punctuation">.</span>body<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于 <code>ref</code> 语法糖而言，<code>compileScript()</code> 函数首先会获取选项（Option）中 <code>refTransform</code> 的值，并赋值给 <code>enableRefTransform</code>：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> enableRefTransform <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>refTransform<span class="token punctuation">;</span>
</code></pre></div><p><code>enableRefTransform</code> 则会用于之后判断是否要调用 <code>ref</code> 语法糖相关的转换函数。那么，前面我们也提及要使用 <code>ref</code> 语法糖，需要先给 <code>@vite/plugin-vue</code> 插件选项的 <code>refTransform</code> 属性设置为 <code>true</code>，它会被传入 <code>compileScript()</code> 函数的 <code>options</code>，也就是这里的 <code>options.refTransform</code>。</p><p>接着，会从 <code>sfc</code> 中解构出 <code>scriptSetup</code>、<code>source</code>、<code>filename</code> 等属性。其中，会先用源文件的代码字符串 <code>source</code> 创建一个 <code>MagicString</code> 实例 <code>s</code>，它主要会用于后续代码转换时<strong>对源代码字符串进行替换、添加等操作</strong>，然后会调用 <code>parse()</code> 函数来解析 <code>&lt;script setup&gt;</code> 的内容，即 <code>scriptSetup.content</code>，从而生成对应的抽象语法树 <code>scriptSetupAst</code>：</p><div class="language-javascript"><pre><code><span class="token keyword">let</span> <span class="token punctuation">{</span> script<span class="token punctuation">,</span> scriptSetup<span class="token punctuation">,</span> source<span class="token punctuation">,</span> filename <span class="token punctuation">}</span> <span class="token operator">=</span> sfc<span class="token punctuation">;</span>
<span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MagicString</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> startOffset <span class="token operator">=</span> scriptSetup<span class="token punctuation">.</span>loc<span class="token punctuation">.</span>start<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>
<span class="token keyword">const</span> scriptSetupAst <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>
  scriptSetup<span class="token punctuation">.</span>content<span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>plugins<span class="token punctuation">,</span> <span class="token string">&quot;topLevelAwait&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    sourceType<span class="token operator">:</span> <span class="token string">&quot;module&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  startOffset
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而 <code>parse()</code> 函数内部则是使用的 <code>@babel/parser</code> 提供的 <code>parser</code> 方法进行代码的解析并生成对应的 AST。对于上面我们这个例子，生成的 AST 会是这样：</p><div class="language-javascript"><pre><code><span class="token punctuation">{</span>
  body<span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
  directives<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  end<span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
  interpreter<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  loc<span class="token operator">:</span> <span class="token punctuation">{</span>
    start<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    end<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    identifierName<span class="token operator">:</span> <span class="token keyword">undefined</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  sourceType<span class="token operator">:</span> <span class="token string">&#39;module&#39;</span><span class="token punctuation">,</span>
  start<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> <span class="token string">&#39;Program&#39;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意，这里省略了 <code>body</code>、<code>start</code>、<code>end</code> 中的内容</p></blockquote><p>然后，会根据前面定义的 <code>enableRefTransform</code> 和调用 <code>shouldTransformRef()</code> 函数的返回值（<code>true</code> 或 <code>false</code>）来判断是否进行 <code>ref</code> 语法糖的代码转换。如果，需要进行相应的转换，则会调用 <code>transformRefAST()</code> 函数来根据 AST 来进行相应的代码转换操作：</p><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>enableRefTransform <span class="token operator">&amp;&amp;</span> <span class="token function">shouldTransformRef</span><span class="token punctuation">(</span>scriptSetup<span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> rootVars<span class="token punctuation">,</span> importedHelpers <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">transformRefAST</span><span class="token punctuation">(</span>
    scriptSetupAst<span class="token punctuation">,</span>
    s<span class="token punctuation">,</span>
    startOffset<span class="token punctuation">,</span>
    refBindings
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在前面，我们已经介绍过了 <code>enableRefTransform</code>。这里我们来看一下 <code>shouldTransformRef()</code> 函数，它主要是通过正则匹配代码内容 <code>scriptSetup.content</code> 来判断是否使用了 <code>ref</code> 语法糖：</p><div class="language-javascript"><pre><code><span class="token comment">// packages/ref-transform/src/refTransform.ts</span>
<span class="token keyword">const</span> transformCheckRE <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[^\w]\$(?:\$|ref|computed|shallowRef)?\(</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">shouldTransform</span><span class="token punctuation">(</span><span class="token parameter">src<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
  <span class="token keyword">return</span> transformCheckRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以，当你指定了 <code>refTransform</code> 为 <code>true</code>，但是你代码中实际并没有使用到 <code>ref</code> 语法糖，则在编译 <code>&lt;script&gt;</code> 或 <code>&lt;script setup&gt;</code> 的过程中也<strong>不会执行</strong>和 <code>ref</code> 语法糖相关的代码转换操作，这也是 Vue3 考虑比较细致的地方，避免了不必要的代码转换操作带来性能上的开销。</p><p>那么，对于我们这个例子而言（使用了 <code>ref</code> 语法糖），则会命中上面的 <code>transformRefAST()</code> 函数。而 <code>transformRefAST()</code> 函数则对应的是 <code>packages/ref-transform/src/refTransform.ts</code> 中的 <code>transformAST()</code> 函数。</p><p>所以，下面我们来看一下 <code>transformAST()</code> 函数是如何根据 AST 来对 <code>ref</code> 语法糖相关代码进行转换操作的。</p><h3 id="transformast-函数"><a class="header-anchor" href="#transformast-函数" aria-hidden="true">#</a> transformAST() 函数</h3><p>在 <code>transformAST()</code> 函数中主要是会遍历传入的原代码对应的 AST，然后通过操作源代码字符串生成的 <code>MagicString</code> 实例 <code>s</code> 来对源代码进行特定的转换，例如重写 <code>$ref</code> 为 <code>_ref</code>、添加 <code>.value</code> 等。</p><p><code>transformAST()</code> 函数的定义（伪代码）：</p><div class="language-javascript"><pre><code><span class="token comment">// packages/ref-transform/src/refTransform.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">transformAST</span><span class="token punctuation">(</span>
  <span class="token parameter">ast<span class="token operator">:</span> Program<span class="token punctuation">,</span>
  s<span class="token operator">:</span> MagicString<span class="token punctuation">,</span>
  offset<span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  knownRootVars<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">walkScope</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
  <span class="token punctuation">(</span>walk <span class="token keyword">as</span> any<span class="token punctuation">)</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">enter</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token operator">:</span> Node<span class="token punctuation">,</span> parent<span class="token operator">?</span><span class="token operator">:</span> Node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;Identifier&#39;</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">isReferencedIdentifier</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token operator">!</span><span class="token punctuation">,</span> parentStack<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span>excludedIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> i <span class="token operator">=</span> scopeStack<span class="token punctuation">.</span>length
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRefId</span><span class="token punctuation">(</span>scopeStack<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> parent<span class="token operator">!</span><span class="token punctuation">,</span> parentStack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    rootVars<span class="token operator">:</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>rootScope<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> rootScope<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    importedHelpers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>importedHelpers<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到 <code>transformAST()</code> 会先调用 <code>walkScope()</code> 来处理根作用域（<code>root scope</code>），然后调用 <code>walk()</code> 函数逐层地处理 AST 节点，而这里的 <code>walk()</code> 函数则是使用的 Rich Haris 写的 <code>estree-walker</code>。</p><p>下面，我们来分别看一下 <code>walkScope()</code> 和 <code>walk()</code> 函数做了什么。</p><h4 id="walkscope-函数"><a class="header-anchor" href="#walkscope-函数" aria-hidden="true">#</a> walkScope() 函数</h4><p>首先，这里我们先来看一下前面使用 <code>ref</code> 语法糖的声明语句 <code>let count = $ref(1)</code> 对应的 AST 结构：</p><img src="https://wuzhiwei.oss-cn-beijing.aliyuncs.com/Blog/vue3/%E6%88%AA%E5%B1%8F2021-09-11%20%E4%B8%8A%E5%8D%8810.14.15.png" height="500"><p>可以看到 <code>let</code> 的 AST 节点类型 <code>type</code> 会是 <code>VariableDeclaration</code>，其余的代码部分对应的 AST 节点则会被放在 <code>declarations</code> 中。其中，变量 <code>count</code> 的 AST 节点会被作为 <code>declarations.id</code> ，而 <code>$ref(1)</code> 的 AST 节点会被作为 <code>declarations.init</code>。</p><p>那么，回到 <code>walkScope()</code> 函数，它会根据 AST 节点的类型 <code>type</code> 进行特定的处理，对于我们这个例子 <code>let</code> 对应的 AST 节点 <code>type</code> 为 <code>VariableDeclaration</code> 会命中这样的逻辑：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">walkScope</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token operator">:</span> Program <span class="token operator">|</span> BlockStatement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> stmt <span class="token keyword">of</span> node<span class="token punctuation">.</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stmt<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;VariableDeclaration&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> decl <span class="token keyword">of</span> stmt<span class="token punctuation">.</span>declarations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> toVarCall
        <span class="token keyword">if</span> <span class="token punctuation">(</span>
          decl<span class="token punctuation">.</span>init <span class="token operator">&amp;&amp;</span>
          decl<span class="token punctuation">.</span>init<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;CallExpression&#39;</span> <span class="token operator">&amp;&amp;</span>
          decl<span class="token punctuation">.</span>init<span class="token punctuation">.</span>callee<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;Identifier&#39;</span> <span class="token operator">&amp;&amp;</span>
          <span class="token punctuation">(</span>toVarCall <span class="token operator">=</span> <span class="token function">isToVarCall</span><span class="token punctuation">(</span>decl<span class="token punctuation">.</span>init<span class="token punctuation">.</span>callee<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">processRefDeclaration</span><span class="token punctuation">(</span>
            toVarCall<span class="token punctuation">,</span>
            decl<span class="token punctuation">.</span>init <span class="token keyword">as</span> CallExpression<span class="token punctuation">,</span>
            decl<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
            stmt
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的 <code>stmt</code> 则是 <code>let</code> 对应的 AST 节点，然后会遍历 <code>stmt.declarations</code>，其中 <code>decl.init.callee.name</code> 指的是 <code>$ref</code>，接着是调用 <code>isToVarCall()</code> 函数并赋值给 <code>toVarCall</code>。</p><p><code>isToVarCall()</code> 函数的定义：</p><div class="language-javascript"><pre><code><span class="token comment">// packages/ref-transform/src/refTransform.ts</span>
<span class="token keyword">const</span> <span class="token constant">TO_VAR_SYMBOL</span> <span class="token operator">=</span> <span class="token string">&quot;$&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> shorthands <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;ref&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;computed&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;shallowRef&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">isToVarCall</span><span class="token punctuation">(</span><span class="token parameter">callee<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token operator">|</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callee <span class="token operator">===</span> <span class="token constant">TO_VAR_SYMBOL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token constant">TO_VAR_SYMBOL</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callee<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token constant">TO_VAR_SYMBOL</span> <span class="token operator">&amp;&amp;</span> shorthands<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>callee<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> callee<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在前面我们也提及 <code>ref</code> 语法糖可以支持其他写法，由于我们使用的是 <code>$ref</code> 的方式，所以这里会命中 <code>callee[0] === TO_VAR_SYMBOL &amp;&amp; shorthands.includes(callee.slice(1))</code> 的逻辑，即 <code>toVarCall</code> 会被赋值为 <code>$ref</code>。</p><p>然后，会调用 <code>processRefDeclaration()</code> 函数，它会根据传入的 <code>decl.init</code> <strong>提供的位置信息</strong>来对源代码对应的 <code>MagicString</code> 实例 <code>s</code> 进行操作，即将 <code>$ref</code> 重写为 <code>ref</code>：</p><div class="language-javascript"><pre><code><span class="token comment">// packages/ref-transform/src/refTransform.ts</span>
<span class="token keyword">function</span> <span class="token function">processRefDeclaration</span><span class="token punctuation">(</span>
    method<span class="token operator">:</span> string<span class="token punctuation">,</span>
    call<span class="token operator">:</span> CallExpression<span class="token punctuation">,</span>
    id<span class="token operator">:</span> VariableDeclarator<span class="token punctuation">[</span><span class="token string">&#39;id&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    statement<span class="token operator">:</span> VariableDeclaration
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;Identifier&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">registerRefBinding</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
    s<span class="token punctuation">.</span><span class="token function">overwrite</span><span class="token punctuation">(</span>
      call<span class="token punctuation">.</span>start<span class="token operator">!</span> <span class="token operator">+</span> offset<span class="token punctuation">,</span>
      call<span class="token punctuation">.</span>start<span class="token operator">!</span> <span class="token operator">+</span> method<span class="token punctuation">.</span>length <span class="token operator">+</span> offset<span class="token punctuation">,</span>
      <span class="token function">helper</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>位置信息指的是该 AST 节点在源代码中的位置，通常会用 <code>start</code>、<code>end</code> 表示，例如这里的 <code>let count = $ref(1)</code>，那么 <code>count</code> 对应的 AST 节点的 <code>start</code> 会是 4、<code>end</code> 会是 9。</p></blockquote><p>因为，此时传入的 <code>id</code> 对应的是 <code>count</code> 的 AST 节点，它会是这样：</p><div class="language-javascript"><pre><code><span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">&quot;Identifier&quot;</span><span class="token punctuation">,</span>
  start<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
  end<span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&quot;count&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以，这会命中上面的 <code>id.type === &#39;Identifier&#39;</code> 的逻辑。首先，会调用 <code>registerRefBinding()</code> 函数，它实际上是调用的是 <code>registerBinding()</code>，而 <code>registerBinding</code> 会在<strong>当前作用域</strong> <code>currentScope</code> 上绑定该变量 <code>id.name</code> 并设置为 <code>true</code> ，它表示这是一个用 <code>ref</code> 语法糖创建的变量，这会用于后续判断是否给某个变量添加 <code>.value</code>：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">registerRefBinding</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">id<span class="token operator">:</span> Identifier</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">registerBinding</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">registerBinding</span><span class="token punctuation">(</span><span class="token parameter">id<span class="token operator">:</span> Identifier<span class="token punctuation">,</span> isRef <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  excludedIds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentScope<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentScope<span class="token punctuation">[</span>id<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> isRef<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">error</span><span class="token punctuation">(</span>
      <span class="token string">&quot;registerBinding called without active scope, something is wrong.&quot;</span><span class="token punctuation">,</span>
      id
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，在 <code>registerBinding()</code> 中还会给 <code>excludedIds</code> 中添加该 AST 节点，而 <code>excludeIds</code> 它是一个 <code>WeekMap</code>，它会用于后续跳过不需要进行 <code>ref</code> 语法糖处理的类型为 <code>Identifier</code> 的 AST 节点。</p><p>然后，会调用 <code>s.overwrite()</code> 函数来将 <code>$ref</code> 重写为 <code>_ref</code>，它会接收 3 个参数，分别是重写的起始位置、结束位置以及要重写为的字符串。而 <code>call</code> 则对应着 <code>$ref(1)</code> 的 AST 节点，它会是这样：</p><div class="language-javascript"><pre><code><span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">&quot;Identifier&quot;</span><span class="token punctuation">,</span>
  start<span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
  end<span class="token operator">:</span> <span class="token number">19</span><span class="token punctuation">,</span>
  callee<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
  arguments<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  optional<span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>并且，我想大家应该注意到了在计算重写的起始位置的时候用到了 <code>offset</code>，它代表着此时操作的字符串在源字符串中的<strong>偏移位置</strong>，例如该字符串在源字符串中的开始，那么偏移量则会是 <code>0</code>。</p><p>而 <code>helper()</code> 函数则会返回字符串 <code>_ref</code>，并且在这个过程会将 <code>ref</code> 添加到 <code>importedHelpers</code> 中，这会在 <code>compileScript()</code> 时用于生成对应的 <code>import</code> 语句：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">msg<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  importedHelpers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>msg<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么，到这里就完成了对 <code>$ref</code> 到 <code>_ref</code> 的重写，也就是此时我们代码的会是这样：</p><div class="language-javascript"><pre><code><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token function">_ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着，则是通过 <code>walk()</code> 函数来将 <code>count++</code> 转换成 <code>count.value++</code>。下面，我们来看一下 <code>walk()</code> 函数。</p><h4 id="walk-函数"><a class="header-anchor" href="#walk-函数" aria-hidden="true">#</a> walk() 函数</h4><p>前面，我们提及 <code>walk()</code> 函数使用的是 Rich Haris 写的 <a href="https://github.com/Rich-Harris/estree-walker" target="_blank" rel="noopener noreferrer">estree-walker</a>，它是一个用于遍历符合 <a href="https://hexdocs.pm/estree/ESTree.html" target="_blank" rel="noopener noreferrer">ESTree</a> 规范的 AST 包（Package）。</p><p><code>walk()</code> 函数使用起来会是这样：</p><div class="language-javascript"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> walk <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;estree-walker&quot;</span><span class="token punctuation">;</span>

<span class="token function">walk</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">enter</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">leave</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到，<code>walk()</code> 函数中可以传入 <code>options</code>，其中 <code>enter()</code> 在每次访问 AST 节点的时候会被调用，<code>leave()</code> 则是在离开 AST 节点的时候被调用。</p><p>那么，回到前面提到的这个例子，<code>walk()</code> 函数主要做了这 2 件事：</p><p><strong>1.维护 scopeStack、parentStack 和 currentScope</strong></p><p><code>scopeStack</code> 用于存放此时 AST 节点所处的作用域链，初始情况下栈顶为根作用域 <code>rootScope</code>；<code>parentStack</code> 用于存放遍历 AST 节点过程中的祖先 AST 节点（栈顶的 AST 节点是当前 AST 节点的父亲 AST 节点）；<code>currentScope</code> 指向当前的作用域，初始情况下等于根作用域 <code>rootScope</code>：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> scopeStack<span class="token operator">:</span> Scope<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>rootScope<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> parentStack<span class="token operator">:</span> Node<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> currentScope<span class="token operator">:</span> Scope <span class="token operator">=</span> rootScope<span class="token punctuation">;</span>
</code></pre></div><p>所以，在 <code>enter()</code> 的阶段会判断此时 AST 节点类型是否为函数、块，是则<strong>入栈</strong> <code>scopeStack</code>：</p><div class="language-javascript"><pre><code>parent <span class="token operator">&amp;&amp;</span> parentStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFunctionType</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scopeStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>currentScope <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;BlockStatement&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isFunctionType</span><span class="token punctuation">(</span>parent<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scopeStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>currentScope <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，在 <code>leave()</code> 的阶段判断此时 AST 节点类型是否为函数、块，是则<strong>出栈</strong> <code>scopeStack</code>，并且更新 <code>currentScope</code> 为出栈后的 <code>scopeStack</code> 的栈顶元素：</p><div class="language-javascript"><pre><code>parent <span class="token operator">&amp;&amp;</span> parentStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>
  <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;BlockStatement&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isFunctionType</span><span class="token punctuation">(</span>parent<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token function">isFunctionType</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scopeStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  currentScope <span class="token operator">=</span> scopeStack<span class="token punctuation">[</span>scopeStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>2.处理 Identifier 类型的 AST 节点</strong></p><p>由于，在我们的例子中 <code>ref</code> 语法糖创建 <code>count</code> 变量的 AST 节点类型是 <code>Identifier</code>，所以这会在 <code>enter()</code> 阶段命中这样的逻辑：</p><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>
    node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;Identifier&#39;</span> <span class="token operator">&amp;&amp;</span>
    <span class="token function">isReferencedIdentifier</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token operator">!</span><span class="token punctuation">,</span> parentStack<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>excludedIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> scopeStack<span class="token punctuation">.</span>length
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRefId</span><span class="token punctuation">(</span>scopeStack<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> parent<span class="token operator">!</span><span class="token punctuation">,</span> parentStack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>在 <code>if</code> 的判断中，对于 <code>excludedIds</code> 我们在前面已经介绍过了，而 <code>isReferencedIdentifier()</code> 则是通过 <code>parenStack</code> 来判断当前类型为 <code>Identifier</code> 的 AST 节点 <code>node</code> 是否是一个引用了这之前的某个 AST 节点。</p><p>然后，再通过访问 <code>scopeStack</code> 来沿着作用域链来判断是否某个作用域中有 <code>id.name</code>（变量名 <code>count</code>）属性以及属性值为 <code>true</code>，这代表它是一个使用 <code>ref</code> 语法糖创建的变量，最后则会通过操作 <code>s</code>（<code>s.appendLeft</code>）来给该变量添加 <code>.value</code>：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">checkRefId</span><span class="token punctuation">(</span>
    <span class="token parameter">scope<span class="token operator">:</span> Scope<span class="token punctuation">,</span>
    id<span class="token operator">:</span> Identifier<span class="token punctuation">,</span>
    parent<span class="token operator">:</span> Node<span class="token punctuation">,</span>
    parentStack<span class="token operator">:</span> Node<span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">.</span>name <span class="token keyword">in</span> scope<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scope<span class="token punctuation">[</span>id<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
      s<span class="token punctuation">.</span><span class="token function">appendLeft</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span>end<span class="token operator">!</span> <span class="token operator">+</span> offset<span class="token punctuation">,</span> <span class="token string">&#39;.value&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过了解 <code>ref</code> 语法糖的实现，我想大家应该会对语法糖这个术语会有不一样的理解，它的本质是在编译阶段通过遍历 AST 来操作特定的代码转换操作。并且，这个实现过程的一些工具包（Package）的配合使用也是非常巧妙的，例如 <code>MagicString</code> 操作源代码字符串、<code>estree-walker</code> 遍历 AST 节点和作用域相关处理等。</p><p>最后，如果文中存在表达不当或错误的地方，欢迎各位同学提 Issue ～</p></div></div><footer class="page-footer" data-v-b109f666 data-v-5a019cc9><div class="edit" data-v-5a019cc9><div class="edit-link" data-v-5a019cc9 data-v-fb0131f2><!----></div></div><div class="updated" data-v-5a019cc9><!----></div></footer><div class="next-and-prev-link" data-v-b109f666 data-v-6683615c><div class="container" data-v-6683615c><div class="prev" data-v-6683615c><a class="link" href="/explain-vue3/chapter9/" data-v-6683615c><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-6683615c><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-6683615c>Introduction</span></a></div><div class="next" data-v-6683615c><!----></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"281a2552\",\"chapter1_index.md\":\"df1b2bf4\",\"chapter2_baseparse.md\":\"39b3f2d2\",\"chapter2_generate.md\":\"0a49c7e5\",\"chapter2_index.md\":\"db29e25f\",\"chapter2_transform.md\":\"916987ac\",\"chapter3_finishcomponentsetup.md\":\"87f32828\",\"chapter3_index.md\":\"9ea90374\",\"chapter3_setupcomponent.md\":\"cc887f1e\",\"chapter5_depcollection.md\":\"52c1bdb2\",\"chapter5_index.md\":\"9afc6eac\",\"chapter5_notifyupdate.md\":\"f82e5472\",\"chapter5_reactive.md\":\"b0b2e8c5\",\"chapter4_index.md\":\"6b664567\",\"chapter6_index.md\":\"c33f070a\",\"chapter6_teleport.md\":\"37b5fe16\",\"chapter7_index.md\":\"ef6cdd83\",\"chapter7_v-if.md\":\"b1a02c59\",\"chapter7_v-show.md\":\"fb6b149d\",\"chapter8_index.md\":\"ad7b5625\",\"chapter8_stylecssvars.md\":\"2891798e\",\"chapter9_index.md\":\"76aa5a2e\",\"chapter9_ref-sugar.md\":\"43fc6c12\"}")</script>
    <script type="module" async src="/explain-vue3/assets/app.d1857a09.js"></script>
  </body>
</html>