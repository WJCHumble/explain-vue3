import{l as n,f as a,G as s}from"./framework.5c8a4622.js";const t='{"title":"reactive","description":"","frontmatter":{},"headers":[{"level":2,"title":"优点","slug":"优点"},{"level":2,"title":"注意点","slug":"注意点"},{"level":2,"title":"源码实现","slug":"源码实现"},{"level":3,"title":"reactive","slug":"reactive-2"},{"level":3,"title":"toRefs","slug":"torefs"},{"level":2,"title":"总语","slug":"总语"}],"relativePath":"chapter5/reactive.md","lastUpdated":1628927998785}',o={},e=s('<h1 id="reactive"><a class="header-anchor" href="#reactive" aria-hidden="true">#</a> reactive</h1><p><code>reactive</code> API 的定义为传入一个对象并返回一个基于原对象的响应式代理，即返回一个 <code>Proxy</code>，相当于 <code>Vue2x</code> 版本中的 <code>Vue.observer</code>。</p><p>首先，我们需要知道在 <code>Vue3</code> 中除了可以使用原先的 <code>Options API</code>，还可以使用新的语法 <code> Composition API</code>，简易版的 <code>Composition API</code> 看起来会是这样的：</p><div class="language-javascript"><pre><code>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">,</span>\n      increment\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre></div><p>可以看到，没有了我们熟悉的<code>data</code>、<code>computed</code>、<code>methods</code>等等。看起来，似乎有点 <code>React</code>风格，这个提出确实当时社区中引发了很多讨论，说<code>Vue</code>越来越像<code>React</code>....很多人并不是很能接受，具体细节大家可以去阅读 <a href="https://vue-composition-api-rfc.netlify.com/#basic-example" target="_blank" rel="noopener noreferrer">RFC 的介绍</a>。</p><h2 id="优点"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h2><p>回到本篇文章所关注的，很明显 <code>reactive API</code> 是<strong>对标</strong> <code>data</code> 选项，那么相比较 <code>data</code> 选项有哪些优点？</p><p>首先，在 <code>Vue 2x</code> 中数据的响应式处理是基于 <code>Object.defineProperty()</code> 的，但是它只会侦听对象的属性，并不能侦听对象。所以，在添加对象属性的时候，通常需要这样：</p><div class="language-javascript"><pre><code><span class="token comment">// vue2x添加属性</span>\nVue<span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> wjc<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p><code>reactive API</code> 是基于 <code>ES2015 Proxy</code> 实现对<strong>数据对象</strong>的响应式处理，即在 <code>Vue3</code> 可以往对象中添加属性，并且这个属性也会具有响应式的效果，例如：</p><div class="language-javascript"><pre><code><span class="token comment">// vue3.0中添加属性</span>\nobject<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;wjc&quot;</span><span class="token punctuation">;</span>\n</code></pre></div><h2 id="注意点"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h2><p>使用 <code>reactive API</code> 需要注意的是，当你在 <code>setup</code> 中返回的时候，需要通过对象的形式，例如：</p><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      y<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      pos<span class="token operator">:</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><p>或者，借助 <code>toRefs API</code> 包裹一下导出，这种情况下我们就可以使用展开运算符或解构，例如：</p><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      y<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    state <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token operator">...</span>state<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><blockquote><p>toRefs() 具体做了什么，接下来会和 reactive 一起讲解</p></blockquote><h2 id="源码实现"><a class="header-anchor" href="#源码实现" aria-hidden="true">#</a> 源码实现</h2><p>首先，相信大家都有所耳闻，<code>Vue3</code> 用 <code>TypeScript</code> 重构了。所以，大家可能会以为这次会看到一堆 <code>TypeScript</code> 的类型之类的。出于各种考虑，本次我只是讲解编译后，转为 JS 的源码实现（没啥子门槛，大家放心 hh）。</p><h3 id="reactive-2"><a class="header-anchor" href="#reactive-2" aria-hidden="true">#</a> reactive</h3><p>1.先来看看 <code>reactive</code> 函数的实现：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// if trying to observe a readonly proxy, return the readonly version.</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>readonlyToRaw<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// target is explicitly marked as readonly by user</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>readonlyValues<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">readonly</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRef</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>\n    target<span class="token punctuation">,</span>\n    rawToReactive<span class="token punctuation">,</span>\n    reactiveToRaw<span class="token punctuation">,</span>\n    mutableHandlers<span class="token punctuation">,</span>\n    mutableCollectionHandlers\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>可以，看到先有 3 个逻辑判断，对 <code>readonly</code>、<code>readonlyValues</code>、<code>isRef</code> 分别进行了判断。我们先不看这些逻辑，通常我们定义 <code>reactive</code> 会直接传入一个对象。所以会命中最后的逻辑 <code>createReactiveObject()</code>。</p><p>2.那我们转到 <code>createReactiveObject()</code> 的定义：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>\n  <span class="token parameter">target<span class="token punctuation">,</span>\n  toProxy<span class="token punctuation">,</span>\n  toRaw<span class="token punctuation">,</span>\n  baseHandlers<span class="token punctuation">,</span>\n  collectionHandlers</span>\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&quot;production&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">value cannot be made reactive: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">String</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// target already has corresponding Proxy</span>\n  <span class="token keyword">let</span> observed <span class="token operator">=</span> toProxy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>observed <span class="token operator">!==</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> observed<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// target is already a Proxy</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>toRaw<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// only a whitelist of value types can be observed.</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canObserve</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">const</span> handlers <span class="token operator">=</span> collectionTypes<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>\n    <span class="token operator">?</span> collectionHandlers\n    <span class="token operator">:</span> baseHandlers<span class="token punctuation">;</span>\n  observed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handlers<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  toProxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> observed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  toRaw<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>observed<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> observed<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><code>createReactiveObject()</code> 传入了四个参数，它们分别扮演的角色：</p><ul><li><code>target</code> 是我们定义 <code>reactive</code> 时传入的对象</li><li><code>toProxy</code> 是一个空的 <code>WeakSet</code>。</li><li><code>toProxy</code> 是一个空的 <code>WeakSet</code>。</li><li><code>baseHandlers</code> 是一个已经定义好 <code>get</code> 和 <code>set</code> 的对象，它看起来会是这样：</li></ul><div class="language-javascript"><pre><code>    <span class="token keyword">const</span> baseHandlers <span class="token operator">=</span> <span class="token punctuation">{</span>\n        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        deleteProxy<span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        has<span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        ownKey<span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><ul><li><code>collectionHandlers</code> 是一个只包含 get 的对象。</li></ul><p>然后，进入 <code>createReactiveObject()</code>， 同样地，一些分支逻辑我们这次不会去分析。</p><blockquote><p>看源码时需要保持的一个平常心，先看主逻辑</p></blockquote><p>所以，我们会命中最后的逻辑，即：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> collectionTypes<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>\n  <span class="token operator">?</span> collectionHandlers\n  <span class="token operator">:</span> baseHandlers<span class="token punctuation">;</span>\nobserved <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handlers<span class="token punctuation">)</span><span class="token punctuation">;</span>\ntoProxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> observed<span class="token punctuation">)</span><span class="token punctuation">;</span>\ntoRaw<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>observed<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>它首先判断 <code>collectionTypes</code> 中是否会包含我们传入的 <code>target</code> 的构造函数，而 <code>collectionTypes</code> 是一个 <code>Set</code> 集合，主要包含 <code>Set</code>, <code>Map</code>, <code>WeakMap</code>, <code>WeakSet</code> 等四种集合的构造函数。</p><p>如果 <code>collectionTypes</code> 包含它的构造函数，那么将 <code>handlers</code> 赋值为只有 <code>get</code> 的 <code>collectionHandlers</code> 对象，否则，赋值为 <code>baseHandlers</code> 对象。</p><blockquote><p>这两者的区别就在于前者只有 get，很显然这个是留给不需要派发更新的变量定义的，例如我们熟悉的 props 它就只实现了 get。</p></blockquote><p>然后，将 <code>target</code> 和 <code>handlers</code> 传入 <code>Proxy</code>，作为参数实例化一个 <code>Proxy</code> 对象。这也是我们看到一些文章常谈的 <code>Vue3</code> 用 <code>ES2015 Proxy</code> 取代了 <code>Object.defineProperty</code>。</p><p>最后的两个逻辑，也是非常重要，<code>toProxy()</code> 将已经定义好 <code>Proxy</code> 对象的 <code>target</code> 和 对应的 <code>observed</code> 作为键值对塞进 <code>toProxy</code> 这个 <code>WeakMap</code> 中，用于下次如果存在相同引用的 target 需要 reactive，会命中前面的分支逻辑，返回定义之前定义好的 <code>observed</code>，即：</p><div class="language-javascript"><pre><code><span class="token comment">// target already has corresponding Proxy target 是已经有相关的 Proxy 对象</span>\n<span class="token keyword">let</span> observed <span class="token operator">=</span> toProxy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>observed <span class="token operator">!==</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> observed<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>而 <code>toRaw()</code> 则是和 <code>toProxy</code> 相反的键值对存入，用于下次如果传进的 <code>target</code> 已经是一个 <code>Proxy</code> 对象时，返回这个 <code>target</code>，即：</p><div class="language-javascript"><pre><code><span class="token comment">// target is already a Proxy target 已经是一个 Proxy 对象</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>toRaw<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="torefs"><a class="header-anchor" href="#torefs" aria-hidden="true">#</a> toRefs</h3><p>前面讲了使用 <code>reactive</code> 需要关注的点，提及 <code>toRefs</code> 可以让我们方便地使用解构和展开运算符，其实是最近 <code>Vue3 issue</code> 也有同学讲解过这方面的东西。有兴趣的同学可以移步 <a href="https://github.com/vuejs/rfcs/issues/145#issuecomment-602171029" target="_blank" rel="noopener noreferrer">When it&#39;s really needed to use <code>toRefs</code> in order to retain reactivity of <code>reactive</code> value</a>了解。</p><p>我当时也凑了一下热闹，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/23/171056493a9e69ae?w=941&amp;h=764&amp;f=png&amp;s=63212" alt=""></p><p>可以看到，<code>toRefs</code> 是在原有 <code>Proxy</code> 对象的基础上，返回了一个普通的带有 <code>get</code> 和 <code>set</code> 的对象。这样就解决了 <code>Proxy</code> 对象遇到解构和展开运算符后，失去引用的情况的问题。</p><h2 id="总语"><a class="header-anchor" href="#总语" aria-hidden="true">#</a> 总语</h2><p>好了，对于 <code>reactive API</code> 的定义和大致的源码实现就如上面文章中描述的。而分支的逻辑，大家可以自行走不同的 <code>case</code> 去阅读。当然，需要说的是这次的源码只是<strong>尝鲜版的</strong>，不排除之后正式的会做诸多优化，但是主体肯定是保持不变的。</p>',48);o.render=function(s,t,o,p,c,u){return n(),a("div",null,[e])};export default o;export{t as __pageData};
