import{l as n,f as s,G as a}from"./framework.5c8a4622.js";const t='{"title":"teleport","description":"","frontmatter":{},"headers":[{"level":2,"title":"compile 编译生成的 render 函数","slug":"compile-编译生成的-render-函数"},{"level":2,"title":"runtime 运行时的 patch 处理","slug":"runtime-运行时的-patch-处理"},{"level":2,"title":"总结","slug":"总结"}],"relativePath":"chapter6/teleport.md","lastUpdated":1628927998786}',o={},p=a('<h1 id="teleport"><a class="header-anchor" href="#teleport" aria-hidden="true">#</a> teleport</h1><p>首先，我们从使用性的角度思考 <code>teleport</code> 组件<strong>能带给我们什么价值</strong>？</p><p><strong>最经典的回答</strong>就是开发中使用 <code>Modal</code> 模态框的场景。通常，我们会在中后台的业务开发中频繁地使用到模态框。可能对于中台还好，它们会搞一些 <code>low code</code> 来<strong>减少开发成本</strong>，但这也是一般大公司或者技术较强的公司才能实现的。</p><p>而实际情况下，我们传统的后台开发，就是会存在频繁地<strong>手动使用</strong> <code>Modal</code> 的情况，它看起来会是这样：</p><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;page&quot;</span><span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;header&quot;</span><span class="token operator">&gt;</span>我希望点击我出现弹窗<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>假设此处有 <span class="token number">100</span> 行代码<span class="token operator">--</span><span class="token operator">&gt;</span>\n  <span class="token operator">...</span><span class="token punctuation">.</span>\n  <span class="token operator">&lt;</span>Modal<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n      我是 header 希望出的弹窗\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>Modal<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n</code></pre></div><p>这样的代码，凸显出来的问题，就是<strong>脱离了所见即所得</strong>的理念，即我头部希望出现的弹窗，<strong>由于样式的问题</strong>，我需要将 <code>Modal</code> 写在最下面。</p><p>而 <code>teleport</code> 组件的出现，<strong>首当其冲</strong>的就是解决这个问题，仍然还是上面那个栗子，通过 <code>teleport</code> 组件我们可以这么写：</p><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;page&quot;</span><span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;header&quot;</span><span class="token operator">&gt;</span>我希望点击我出现弹窗<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>弹窗内容<span class="token operator">--</span><span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span>teleport to<span class="token operator">=</span><span class="token string">&quot;#modal-header&quot;</span><span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n      我是 header 希望出的弹窗\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>teleport<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>假设此处有 <span class="token number">100</span> 行代码<span class="token operator">--</span><span class="token operator">&gt;</span>\n  <span class="token operator">...</span><span class="token punctuation">.</span>\n  <span class="token operator">&lt;</span>Modal id<span class="token operator">=</span><span class="token string">&quot;modal-header&quot;</span><span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>Modal<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n</code></pre></div><p>结合 <code>teleport</code> 组件使用 <code>modal</code>，一方面，我们的弹窗内容，就可以符合我们的正常的思考逻辑。并且，另一方面，也可以充分地提高 <code>Modal</code> 组件的<strong>可复用性</strong>，即页面中一个 <code>Modal</code> 负责展示不同内容。</p><p>假设，此时我们有一个这样的栗子：</p><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;my-heart&quot;</span><span class="token operator">&gt;</span>\n  i love you\n<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span>teleport to<span class="token operator">=</span><span class="token string">&quot;#my-heart&quot;</span> <span class="token operator">&gt;</span>\n  honey\n<span class="token operator">&lt;</span><span class="token operator">/</span>teleport<span class="token operator">&gt;</span>\n</code></pre></div><p>通过上面的介绍，我们很容易就知道，它最终渲染到页面上的 DOM 会是这样：</p><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;my-heart&quot;</span><span class="token operator">&gt;</span>i love you honey<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n</code></pre></div><p>那么，这个时候我们就会想，<code>teleport</code> 组件中的内容，究竟是如何<strong>走进了我的心</strong>？这，说来话长，长话短说，<strong>我们直接上图</strong>：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b53f0591a041a4b50b9577192e54ca~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>通过流程图，我们可以知道整体 <code>teleport</code> 的工作流并不复杂。那么，接下来，我们再从<strong>源码设计</strong>的角度认识 <code>teleport</code> 组件的运行机制。</p><blockquote><p>这里，我们仍然会分为 <code>compile</code> 和 <code>runtime</code> 两个阶段去介绍。</p></blockquote><h2 id="compile-编译生成的-render-函数"><a class="header-anchor" href="#compile-编译生成的-render-函数" aria-hidden="true">#</a> compile 编译生成的 render 函数</h2><p>仍然是我们上面的那个栗子，它经过 <code>compile</code> 编译处理后生成的<strong>可执行代码</strong>会是这样：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> _Vue <span class="token operator">=</span> Vue\n<span class="token keyword">const</span> <span class="token punctuation">{</span> createVNode<span class="token operator">:</span> _createVNode<span class="token punctuation">,</span> createTextVNode<span class="token operator">:</span> _createTextVNode <span class="token punctuation">}</span> <span class="token operator">=</span> _Vue\n\n<span class="token keyword">const</span> _hoisted_1 <span class="token operator">=</span> <span class="token function">_createVNode</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">&quot;my-heart&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;i love you &quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">/* HOISTED */</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> _hoisted_2 <span class="token operator">=</span> <span class="token function">_createTextVNode</span><span class="token punctuation">(</span><span class="token string">&quot;honey&quot;</span><span class="token punctuation">)</span>\n\n<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">_ctx<span class="token punctuation">,</span> _cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">with</span> <span class="token punctuation">(</span>_ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> createVNode<span class="token operator">:</span> _createVNode<span class="token punctuation">,</span> createTextVNode<span class="token operator">:</span> _createTextVNode<span class="token punctuation">,</span> Teleport<span class="token operator">:</span> _Teleport<span class="token punctuation">,</span> openBlock<span class="token operator">:</span> _openBlock<span class="token punctuation">,</span> createBlock<span class="token operator">:</span> _createBlock<span class="token punctuation">,</span> Fragment<span class="token operator">:</span> _Fragment <span class="token punctuation">}</span> <span class="token operator">=</span> _Vue\n\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">_openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_createBlock</span><span class="token punctuation">(</span>_Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n      _hoisted_1<span class="token punctuation">,</span>\n      <span class="token punctuation">(</span><span class="token function">_openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_createBlock</span><span class="token punctuation">(</span>_Teleport<span class="token punctuation">,</span> <span class="token punctuation">{</span> to<span class="token operator">:</span> <span class="token string">&quot;#my-heart&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n        _hoisted_2\n      <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>由于，<code>teleport</code> 组件并不属于静态节点需要提升的范围，所以它会在 <code>render</code> 函数内部创建，即这一部分：</p><div class="language-javascript"><pre><code><span class="token function">_createBlock</span><span class="token punctuation">(</span>_Teleport<span class="token punctuation">,</span> <span class="token punctuation">{</span> to<span class="token operator">:</span> <span class="token string">&quot;#my-heart&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n  _hoisted_2\n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div><blockquote><p>需要注意的是，此时 <code>teleport</code> 的内容 <code>honey</code> 是属于静态节点，所以它会被提升。</p></blockquote><p>并且，这里有一处细节，<code>teleport</code> 组件的内部元素永远是<strong>以数组的形式</strong>处理，这在之后的 <code>patch</code> 处理中也会提及。</p><h2 id="runtime-运行时的-patch-处理"><a class="header-anchor" href="#runtime-运行时的-patch-处理" aria-hidden="true">#</a> runtime 运行时的 patch 处理</h2><p>相比较 <code>compile</code> 编译时生成 <code>teleport</code> 组件的可执行代码，<code>runtime</code> 运行时的 <code>patch</code> 处理可以说是整个 <code>teleport</code> 组件<strong>实现的核心</strong>。</p><p>在上一篇文章 <a href="https://juejin.im/post/6875900681161572365" target="_blank" rel="noopener noreferrer">深度解读 Vue 3 源码 | compile 和 runtime 结合的 patch 过程</a> 中，我们说了 <code>patch</code> 会根据不同的 <code>shapeFlag</code> 处理不同的逻辑，而 <code>teleport</code> 则会命中 <code>shapeFlag</code> 为 <code>TELEPORT</code> 的逻辑：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>\n    <span class="token keyword">default</span><span class="token operator">:</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>shapeFlag <span class="token operator">&amp;</span> ShapeFlags<span class="token punctuation">.</span><span class="token constant">TELEPORT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token punctuation">;</span><span class="token punctuation">(</span>type <span class="token keyword">as</span> <span class="token keyword">typeof</span> TeleportImpl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>\n          n1 <span class="token keyword">as</span> TeleportVNode<span class="token punctuation">,</span>\n          n2 <span class="token keyword">as</span> TeleportVNode<span class="token punctuation">,</span>\n          container<span class="token punctuation">,</span>\n          anchor<span class="token punctuation">,</span>\n          parentComponent<span class="token punctuation">,</span>\n          parentSuspense<span class="token punctuation">,</span>\n          isSVG<span class="token punctuation">,</span>\n          optimized<span class="token punctuation">,</span>\n          internals\n        <span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这里会调用 <code>TeleportImpl</code> 上的 <code>process</code> 方法来实现 <code>teleport</code> 的 <code>patch</code> 过程，并且它也是 <code>teleport</code> 组件实现的<strong>核心代码</strong>。而 <code>TeleportImpl.process</code> 函数的逻辑可以分为这四个步骤：</p><h4 id="创建并挂载注释节点"><a class="header-anchor" href="#创建并挂载注释节点" aria-hidden="true">#</a> 创建并挂载注释节点</h4><p>首先，创建两个注释 <code>VNode</code>，插入此时 <code>teleport</code> 组件在页面中的对应位置，即插入到 <code>teleport</code> 的父节点 <code>container</code> 中：</p><div class="language-javascript"><pre><code><span class="token comment">// 创建注释节点</span>\n<span class="token keyword">const</span> placeholder <span class="token operator">=</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>el <span class="token operator">=</span> __DEV__\n  <span class="token operator">?</span> <span class="token function">createComment</span><span class="token punctuation">(</span><span class="token string">&quot;teleport start&quot;</span><span class="token punctuation">)</span>\n  <span class="token operator">:</span> <span class="token function">createText</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> mainAnchor <span class="token operator">=</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>anchor <span class="token operator">=</span> __DEV__\n  <span class="token operator">?</span> <span class="token function">createComment</span><span class="token punctuation">(</span><span class="token string">&quot;teleport end&quot;</span><span class="token punctuation">)</span>\n  <span class="token operator">:</span> <span class="token function">createText</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 插入注释节点</span>\n<span class="token function">insert</span><span class="token punctuation">(</span>placeholder<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">insert</span><span class="token punctuation">(</span>mainAnchor<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h4 id="挂载-target-节点和占位节点"><a class="header-anchor" href="#挂载-target-节点和占位节点" aria-hidden="true">#</a> 挂载 target 节点和占位节点</h4><p>其次，判断 <code>teleport</code> 组件对应 <code>target</code> 的 <code>DOM</code> 节点是否存在，存在则插入一个<strong>空的文本节点</strong>，也可以称为<strong>占位节点</strong>：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token function">resolveTarget</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>props<span class="token punctuation">,</span> querySelector<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> targetAnchor <span class="token operator">=</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>targetAnchor <span class="token operator">=</span> <span class="token function">createText</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">insert</span><span class="token punctuation">(</span>targetAnchor<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid Teleport target on mount:&quot;</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">typeof</span> target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="定义挂载函数-mount"><a class="header-anchor" href="#定义挂载函数-mount" aria-hidden="true">#</a> 定义挂载函数 mount</h4><p>然后，定义 <code>mount</code> 方法来为 <code>teleport</code> 组件进行特定的挂载操作，它的本质是基于 <code>mountChildren</code> 挂载子元素方法的封装：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">mount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">container<span class="token operator">:</span> RendererElement<span class="token punctuation">,</span> anchor<span class="token operator">:</span> RendererNode</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>shapeFlag <span class="token operator">&amp;</span> ShapeFlags<span class="token punctuation">.</span><span class="token constant">ARRAY_CHILDREN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">mountChildren</span><span class="token punctuation">(</span>\n      children <span class="token keyword">as</span> VNodeArrayChildren<span class="token punctuation">,</span>\n      container<span class="token punctuation">,</span>\n      anchor<span class="token punctuation">,</span>\n      parentComponent<span class="token punctuation">,</span>\n      parentSuspense<span class="token punctuation">,</span>\n      isSVG<span class="token punctuation">,</span>\n      optimized\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>可以看到，这里也对是否 <code>ShpeFlags</code> 为 <code>ARRAY_CHILDREN</code>，<strong>即数组</strong>，进行了判断，因为 <code>teleport</code> 的<strong>子元素必须为数组</strong>。并且，<code>mount</code> 方法的两个形参的意义分别是：</p><ul><li><code>container</code> 代表要挂载的父节点。</li><li><code>anchor</code> 调用 <code>insertBefore</code> 插入时的 <code>referenceNode</code>，即占位 <code>VNode</code>。</li></ul><h4 id="根据-disabled-处理不同逻辑"><a class="header-anchor" href="#根据-disabled-处理不同逻辑" aria-hidden="true">#</a> 根据 disabled 处理不同逻辑</h4><p>由于，<code>teleport</code> 组件提供了一个 <code>props</code> 属性 <code>disabled</code> 来控制是否将内容显示在目标 <code>target</code> 中。所以，最后会根据 <code>disabled</code> 来进行不同逻辑的处理：</p><ul><li><code>disabled</code> 为 <code>true</code> 时，<code>mainAnchor</code> 作为 <code>referenceNode</code>，即<strong>注释节点</strong>，挂载到此时 <code>teleport</code> 的父级节点中。</li><li><code>disabled</code> 为 <code>false</code> 时，<code>targetAnchor</code> 作为 <code>refereneceNode</code>，即 <code>target</code> 中的空文本节点，挂载到此时 <code>teleport</code> 的 <code>target</code> 节点中。</li></ul><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>disabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">mount</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> mainAnchor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">mount</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> targetAnchor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>而 <code>mount</code> 方法最终会调用原始的 <code>DOM API</code> <code>insertBefore</code> 来实现 <code>teleport</code> 内容的挂载。我们来回忆一下 <code>insertBefore</code> 的语法：</p><div class="language-javascript"><pre><code><span class="token keyword">var</span> insertedNode <span class="token operator">=</span> parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> referenceNode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>由于 <code>insertBefore</code> 的第二个参数 <code>referenceNode</code> 是必选的，<strong>如果不提供节点或者传入无效值，在不同的浏览器中会有不同的表现（摘自 MDN）</strong>。所以，当 <code>disabled</code> 为 <code>false</code> 时，我们的 <code>referenceNode</code> 就是一个已插入 <code>target</code> 中的<strong>空文本节点</strong>，从而确保在不同浏览器上都能<strong>表现一致</strong>。</p><h2 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>今天介绍的是属于 <code>teleport</code> 组件创建的逻辑。同样地，<code>teleport</code> 组件也有自己特殊的 <code>patch</code> 逻辑，这里有兴趣的同学可以自行去了解。虽说，<code>teleport</code> 组件的实现并不复杂，但是，其中的<strong>细节处理仍然是值得学习一番</strong>，例如注释节点来标记 <code>teleport</code> 组件位置、空文本节点作为占位节点确保 <code>insertBefore</code> 在不同浏览器上表现一致等。</p>',49);o.render=function(a,t,o,e,c,r){return n(),s("div",null,[p])};export default o;export{t as __pageData};
